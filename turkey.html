<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Turkey Escape: Operation Disguise</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@500&display=swap');

        body {
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            background-color: #2d3748;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .game-font {
            font-family: 'Press Start 2P', cursive;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            max-width: 600px;
            margin: 0 auto;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%);
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* Math UI Overlay */
        #math-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            padding: 20px;
            display: none;
        }

        .math-card {
            background: white;
            border: 4px solid #4A5568;
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            box-shadow: 8px 8px 0px #2D3748;
            text-align: center;
        }

        .answer-btn {
            background: #EDF2F7;
            border: 2px solid #CBD5E0;
            padding: 12px;
            margin: 8px 0;
            width: 100%;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            font-size: 1.1rem;
            text-align: left;
            position: relative;
        }

        .answer-btn:hover {
            background: #BEE3F8;
            transform: translateX(5px);
        }

        .answer-btn:active {
            transform: scale(0.98);
        }

        .correct-anim {
            background-color: #C6F6D5 !important;
            border-color: #48BB78 !important;
        }

        .wrong-anim {
            background-color: #FED7D7 !important;
            border-color: #F56565 !important;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        /* Canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
            pointer-events: none;
        }

        .hud-panel {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            border: 2px solid #fff;
            text-align: right;
        }

        #hearts-display {
            color: #F56565;
            font-size: 20px;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 120px;
            z-index: 15;
            display: none;
            pointer-events: none;
        }

        .d-pad {
            position: absolute;
            bottom: 10px;
            right: 20px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        .d-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            user-select: none;
            touch-action: manipulation;
        }
        
        .d-btn:active { background: rgba(255,255,255,0.8); }
        .d-up { top: 0; left: 35px; }
        .d-down { bottom: 0; left: 35px; }
        
        #jump-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 200, 0, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            user-select: none;
            touch-action: manipulation;
        }
        #jump-btn:active { background: rgba(255, 200, 0, 0.8); }

        /* Start/Fail Screen */
        #start-screen, #fail-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2D3748;
            color: white;
            z-index: 30;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        #fail-overlay {
            background: rgba(100, 0, 0, 0.9);
            z-index: 25;
            display: none;
        }

        .title {
            font-size: 2rem;
            color: #F6E05E;
            text-shadow: 4px 4px #C05621;
            margin-bottom: 20px;
        }
        
        .btn-primary {
            background: #ED8936;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            margin-top: 20px;
            animation: pulse 1.5s infinite;
        }

        .toggle-container {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Run Instructions Flash */
        #run-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: #FFF;
            padding: 20px;
            border-radius: 10px;
            z-index: 25;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            display: none;
            pointer-events: none;
            white-space: pre-wrap;
            line-height: 1.5;
        }

        /* Checkbox Style */
        .custom-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

    </style>
</head>
<body>

<div id="game-container">
    
    <!-- Start Screen -->
    <div id="start-screen">
        <h1 class="title game-font">TURKEY ESCAPE</h1>
        <div style="font-size: 60px; margin: 20px; transform: scaleX(-1); display:inline-block;">ü¶É</div>
        <div style="font-size: 60px; margin: 20px; display:inline-block;">üí®</div>
        <p class="mb-4">Solve math to earn disguise pieces.</p>
        <p class="text-sm text-gray-400">Dodge obstacles. Don't get caught!</p>
        
        <div class="toggle-container">
            <input type="checkbox" id="timer-toggle" class="custom-checkbox">
            <label for="timer-toggle" class="cursor-pointer">Enable Speed Timer</label>
        </div>

        <button class="btn-primary" onclick="startGame()">PLAY</button>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-panel game-font">
            Disguise: <span id="score-val">0</span>/5
            <div id="hud-timer" style="font-size: 12px; margin-top:5px; color: #F6E05E; display:none;">TIME: 00:00</div>
        </div>
        <div class="hud-panel game-font" id="distance-ui" style="display:none">
            Run: <span id="dist-val">0</span>m <br/>
            Health: <span id="hearts-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
        </div>
    </div>

    <!-- Run Instructions Flash -->
    <div id="run-instructions">
        READY?<br/><span style="color:#F6E05E; font-size: 24px;">GO!</span>
    </div>

    <!-- Fail Overlay -->
    <div id="fail-overlay">
        <h2 class="text-3xl font-bold mb-4 game-font text-red-400">CAUGHT!</h2>
        <div style="font-size: 60px; margin-bottom: 20px;">üëÆ‚Äç‚ôÇÔ∏èü¶É</div>
        <p class="mb-6">The turkey was spotted!</p>
        <button class="btn-primary" onclick="Game.retryAfterFail()">TRY AGAIN</button>
    </div>

    <!-- Math Interface -->
    <div id="math-ui">
        <div class="math-card">
            <h2 class="text-xl font-bold text-gray-700 mb-2">Math Challenge!</h2>
            <p class="text-sm text-gray-500 mb-4" id="problem-type">Simplify the expression</p>
            
            <div id="problem-display" class="text-2xl font-bold mb-6 p-4 bg-gray-100 rounded text-gray-800">
                3x + 2x
            </div>

            <div id="options-container">
                <!-- Buttons injected here -->
            </div>

            <div id="feedback-msg" class="mt-4 text-sm font-bold min-h-[20px]"></div>
            
            <button id="next-btn" class="hidden mt-4 bg-blue-500 text-white px-6 py-2 rounded font-bold hover:bg-blue-600">
                Start Running! üèÉ
            </button>
        </div>
    </div>

    <!-- Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div class="d-pad">
            <div class="d-btn d-up" ontouchstart="handleInput(event, 'up')" onmousedown="handleInput(event, 'up')">‚ñ≤</div>
            <div class="d-btn d-down" ontouchstart="handleInput(event, 'down')" onmousedown="handleInput(event, 'down')">‚ñº</div>
        </div>
        <div id="jump-btn" ontouchstart="handleInput(event, 'jump')" onmousedown="handleInput(event, 'jump')">JUMP</div>
    </div>

</div>

<script>
/**
 * AUDIO SYSTEM
 */
const AudioSys = {
    ctx: null,
    init: function() {
        // Initialize Audio Context on first interaction
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playCorrect: function() {
        this.playTone(440, 'sine', 0.1); 
        setTimeout(() => this.playTone(554, 'sine', 0.1), 100); 
        setTimeout(() => this.playTone(659, 'sine', 0.3), 200); 
    },
    playWrong: function() {
        this.playTone(150, 'sawtooth', 0.3);
        setTimeout(() => this.playTone(100, 'sawtooth', 0.4), 150);
    },
    playJump: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    },
    playCrash: function() {
        this.playTone(100, 'square', 0.5);
    },
    playGameOver: function() {
        this.playTone(300, 'sawtooth', 0.3);
        setTimeout(() => this.playTone(200, 'sawtooth', 0.3), 300);
        setTimeout(() => this.playTone(100, 'sawtooth', 0.6), 600);
    },
    playWin: function() {
        [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.2), i * 150));
    }
};

/**
 * MATH GENERATOR
 */
const MathGen = {
    gcd: (a, b) => {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b) {
            var t = b;
            b = a % b;
            a = t;
        }
        return a;
    },

    finalize: (str) => {
        // 1. Remove 0 coefficients like 0x, + 0x, - 0x
        // Regex looks for boundary, optional operator, 0, then variable
        str = str.replace(/(^|[\+\-\s])\s*0[a-z](\^2)?/g, '');
        
        // 2. Normalize signs
        str = str.replace(/\+\s*\-/g, '- ');
        str = str.replace(/\-\s*\-/g, '+ ');
        str = str.replace(/\+\s*\+/g, '+ ');
        
        // 3. Remove "1" from "1x", "-1x"
        str = str.replace(/(^|[\+\-\s])1([a-z])/g, '$1$2');
        
        // 4. Clean up spaces
        str = str.replace(/\s+/g, ''); // strip all
        str = str.replace(/(\+|\-)/g, ' $1 '); // add around ops
        
        // 5. Clean start/end
        str = str.trim();
        if (str.startsWith(" + ")) str = str.substring(3);
        if (str.startsWith("+ ")) str = str.substring(2);
        if (str.startsWith(" - ")) str = "-" + str.substring(3);
        
        // 6. Clean dangling operators at end (rare but possible with regex strip)
        if (str.endsWith(" +") || str.endsWith(" -")) {
            str = str.substring(0, str.length - 2);
        }

        // 7. Handle empty string (result is 0)
        if (str === "") return "0";
        
        return str;
    },

    getRandomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,

    generateProblem: function(difficulty) {
        const type = Math.random() < 0.4 ? 0 : (Math.random() < 0.7 ? 1 : 2); 
        if (type === 0) return this.genCombine(difficulty);
        if (type === 1) return this.genDistributive(difficulty);
        return this.genFactoring(difficulty);
    },

    genCombine: function(diff) {
        const vars = ['x', 'y', 'w', 'a'];
        const v = vars[Math.floor(Math.random()*vars.length)];
        let A = this.getRandomInt(-5, 9); // Allow 0 to test filter
        let B = this.getRandomInt(-5, 9);
        let C = this.getRandomInt(-5, 5);
        let D = this.getRandomInt(1, 5);
        
        let problemStr = `${A}${v} + ${B}y ${C<0?C:'+'+C}${v} - ${D}y`;
        let finalX = A + C;
        let finalY = B - D;
        
        // Ensure not everything is zero to avoid trivial questions often
        if (finalX === 0 && finalY === 0) {
            A = 2; finalX = A+C; // Force one valid term
        }
        
        let correct = `${finalX}${v} ${finalY<0?'-':'+'} ${Math.abs(finalY)}y`;
        let w1 = `${finalX + 1}${v} ${finalY<0?'-':'+'} ${Math.abs(finalY)}y`;
        let w2 = `${finalX}${v}^2 ${finalY<0?'-':'+'} ${Math.abs(finalY)}y`;
        let w3 = `${finalX + finalY}${v}y`;

        return {
            type: "Combine Like Terms",
            text: this.finalize(problemStr),
            correct: this.finalize(correct),
            options: this.shuffle([this.finalize(correct), this.finalize(w1), this.finalize(w2), this.finalize(w3)])
        };
    },

    genDistributive: function(diff) {
        let a = this.getRandomInt(-4, 5);
        if (a === 0 || a === 1) a = 2;
        let b = this.getRandomInt(1, 5);
        let c = this.getRandomInt(-5, 5);
        if (c === 0) c = 3;
        
        let v = 'x';
        let problemStr = `${a}(${b===1?'':b}${v} ${c<0?c:'+'+c})`;
        let term1 = a * b;
        let term2 = a * c;
        let correct = `${term1}${v} ${term2<0?term2:'+'+term2}`;
        
        let w1 = `${a}${v} ${term2<0?term2:'+'+term2}`; 
        let w2 = `${term1}${v} ${c<0?c:'+'+c}`; 
        let w3 = `${term1}${v}^2 ${term2<0?term2:'+'+term2}`; 

        return {
            type: "Distributive Property",
            text: problemStr, 
            correct: this.finalize(correct),
            options: this.shuffle([this.finalize(correct), this.finalize(w1), this.finalize(w2), this.finalize(w3)])
        };
    },

    genFactoring: function(diff) {
        let a = this.getRandomInt(2, 6);
        let b = this.getRandomInt(1, 4);
        let c = this.getRandomInt(1, 5);
        
        let div = this.gcd(b, c);
        b = Math.floor(b / div);
        c = Math.floor(c / div);
        if (c === 0) c = 1;

        let v = 'x';
        let t1 = a * b;
        let t2 = a * c;
        
        let problemStr = `${t1}${v} + ${t2}`;
        let bStr = b === 1 ? v : `${b}${v}`;
        let correct = `${a}(${bStr} + ${c})`;
        
        let w1 = `${a}(${t1}${v} + ${t2})`; 
        let w2 = `${b}(${a}${v} + ${c})`; 
        let w3 = `${t1}(${v} + ${t2})`; 

        return {
            type: "Factor the Expression",
            text: this.finalize(problemStr),
            correct: correct, 
            options: this.shuffle([correct, w1, w2, w3])
        };
    },

    shuffle: function(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
};

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameLoopId;

const Game = {
    state: 'MENU',
    disguisePieces: ['üé©', 'üï∂Ô∏è', 'üßî', 'üëï', 'üíº'],
    currentDisguiseIndex: 0,
    width: 600,
    height: 400,
    lanes: [150, 250, 350], 
    
    // Run State variables
    turkey: { x: 50, y: 250, lane: 1, velY: 0, isJumping: false },
    lives: 3,
    obstacles: [],
    runDistance: 0,
    targetDistance: 500,
    gameSpeed: 3, 
    frameCount: 0,
    lastInputTime: 0,
    isWarmingUp: false,
    
    // Jump constants (Increased jump power and reduced gravity)
    JUMP_VELOCITY: -15, // Increased from -10
    GRAVITY: 0.7,      // Reduced from 0.8 to make jump longer

    // Timer
    timerEnabled: false,
    startTime: 0,
    elapsedMs: 0,

    init: function() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // --- FIX 1: Prevent scrolling on arrow key press ---
        window.addEventListener('keydown', (e) => {
            if (this.state === 'RUN') {
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === ' ') {
                    e.preventDefault(); // Stop default browser scrolling behavior
                }
                
                if (e.key === 'ArrowUp') this.moveTurkey(-1);
                if (e.key === 'ArrowDown') this.moveTurkey(1);
                if (e.key === ' ' || e.key === 'ArrowRight') this.jumpTurkey();
            }
        });
    },

    resize: function() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        this.width = canvas.width;
        this.height = canvas.height;
        let laneH = this.height / 4;
        this.lanes = [laneH + 20, laneH*2 + 20, laneH*3 + 20];
        this.turkey.y = this.lanes[1];
    },

    start: function() {
        const toggle = document.getElementById('timer-toggle');
        this.timerEnabled = toggle.checked;
        if(this.timerEnabled) {
            document.getElementById('hud-timer').style.display = 'block';
            this.startTime = Date.now();
        }

        document.getElementById('start-screen').style.display = 'none';
        AudioSys.init();
        this.startMathPhase();
        this.gameLoop();
    },

    startMathPhase: function() {
        this.state = 'MATH';
        document.getElementById('math-ui').style.display = 'flex';
        document.getElementById('mobile-controls').style.display = 'none';
        document.getElementById('distance-ui').style.display = 'none';
        document.getElementById('fail-overlay').style.display = 'none';
        
        const problem = MathGen.generateProblem();
        this.renderMathProblem(problem);
    },

    renderMathProblem: function(p) {
        document.getElementById('problem-type').textContent = p.type;
        let htmlText = p.text.replace(/\^\{(\d+)\}/g, '<sup>$1</sup>').replace(/\^2/g, '<sup>2</sup>');
        document.getElementById('problem-display').innerHTML = htmlText;
        
        const optsContainer = document.getElementById('options-container');
        optsContainer.innerHTML = '';
        document.getElementById('feedback-msg').textContent = '';
        document.getElementById('next-btn').classList.add('hidden');

        p.options.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = 'answer-btn';
            btn.innerHTML = opt.replace(/\^\{(\d+)\}/g, '<sup>$1</sup>').replace(/\^2/g, '<sup>2</sup>');
            btn.onclick = () => this.checkAnswer(opt, p.correct, btn);
            optsContainer.appendChild(btn);
        });
    },

    checkAnswer: function(selected, correct, btnElement) {
        const feedback = document.getElementById('feedback-msg');
        const nextBtn = document.getElementById('next-btn');
        const allBtns = document.querySelectorAll('.answer-btn');
        allBtns.forEach(b => b.disabled = true);

        if (selected === correct) {
            btnElement.classList.add('correct-anim');
            feedback.textContent = "Correct! Get ready to run!";
            feedback.classList.add('text-green-600');
            feedback.classList.remove('text-red-600');
            AudioSys.playCorrect();
            nextBtn.classList.remove('hidden');
            nextBtn.textContent = "Start Running! üèÉ";
            nextBtn.onclick = () => this.startRunPhase();
        } else {
            btnElement.classList.add('wrong-anim');
            feedback.innerHTML = `Incorrect. The correct answer was: <span class="text-green-600">${correct}</span>`;
            feedback.classList.add('text-red-600');
            AudioSys.playWrong();
            nextBtn.textContent = "Try Next Problem";
            nextBtn.classList.remove('hidden');
            nextBtn.onclick = () => this.startMathPhase();
        }
    },

    startRunPhase: function() {
        this.state = 'RUN';
        this.isWarmingUp = true; 
        
        document.getElementById('math-ui').style.display = 'none';
        
        if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.getElementById('mobile-controls').style.display = 'block';
        }
        document.getElementById('distance-ui').style.display = 'block';
        
        const instr = document.getElementById('run-instructions');
        instr.style.display = 'block';
        setTimeout(() => {
            instr.style.display = 'none';
            this.isWarmingUp = false;
        }, 1500);

        this.turkey.lane = 1;
        this.turkey.y = this.lanes[1];
        this.turkey.isJumping = false;
        this.obstacles = [];
        this.runDistance = 0;
        this.lives = 3; 
        this.updateHearts();
        
        // DISTANCE LOGIC: Round 1 = 1000m. Add 250m per subsequent round.
        // Index 0 -> 1000. Index 1 -> 1250, etc.
        this.targetDistance = 1000 + (this.currentDisguiseIndex * 250);
        
        this.gameSpeed = 3 + (this.currentDisguiseIndex * 0.8);
    },

    updateHearts: function() {
        let h = "";
        for(let i=0; i<this.lives; i++) h += "‚ù§Ô∏è";
        if (this.lives === 0) h = "üíî";
        document.getElementById('hearts-display').textContent = h;
    },

    retryAfterFail: function() {
        document.getElementById('fail-overlay').style.display = 'none';
        this.startMathPhase();
    },

    moveTurkey: function(dir) {
        if (this.state !== 'RUN' || this.isWarmingUp) return;
        
        const now = Date.now();
        if (now - this.lastInputTime < 150) return; 
        this.lastInputTime = now;

        this.turkey.lane += dir;
        if (this.turkey.lane < 0) this.turkey.lane = 0;
        if (this.turkey.lane > 2) this.turkey.lane = 2;
    },

    jumpTurkey: function() {
        if (this.state !== 'RUN' || this.isWarmingUp || this.turkey.isJumping) return;
        this.turkey.isJumping = true;
        // Apply the increased jump velocity
        this.turkey.velY = this.JUMP_VELOCITY; 
        AudioSys.playJump();
    },

    formatTime: function(ms) {
        let sec = Math.floor(ms / 1000);
        let min = Math.floor(sec / 60);
        sec = sec % 60;
        return `${min}:${sec < 10 ? '0'+sec : sec}`;
    },

    update: function() {
        if (this.timerEnabled && this.state !== 'MENU' && this.state !== 'FAIL') {
            const now = Date.now();
            this.elapsedMs = now - this.startTime;
            document.getElementById('hud-timer').textContent = "TIME: " + this.formatTime(this.elapsedMs);
        }

        if (this.state !== 'RUN' || this.isWarmingUp) return;

        this.frameCount++;
        this.runDistance += this.gameSpeed / 10;
        document.getElementById('dist-val').textContent = Math.floor(this.runDistance);

        if (this.runDistance >= this.targetDistance) {
            this.completeRound();
            return;
        }

        let targetY = this.lanes[this.turkey.lane];
        if (this.turkey.isJumping) {
            this.turkey.y += this.turkey.velY;
            // Use the reduced gravity constant
            this.turkey.velY += this.GRAVITY; 
            if (this.turkey.y >= targetY) {
                this.turkey.y = targetY;
                this.turkey.isJumping = false;
                this.turkey.velY = 0; // Reset velocity when landing
            }
        } else {
            this.turkey.y += (targetY - this.turkey.y) * 0.2;
        }

        let spawnRate = Math.floor(160 - (this.currentDisguiseIndex * 15));
        if (spawnRate < 60) spawnRate = 60; 

        if (this.frameCount % spawnRate === 0) {
            const lane = Math.floor(Math.random() * 3);
            const type = Math.random() > 0.6 ? 'tree' : (Math.random() > 0.5 ? 'rock' : 'fence');
            this.obstacles.push({
                x: this.width + 50,
                y: this.lanes[lane],
                type: type,
                lane: lane,
                width: 40,
                height: 40,
                hit: false
            });
        }

        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            let obs = this.obstacles[i];
            obs.x -= this.gameSpeed;

            if (!obs.hit && Math.abs(obs.x - this.turkey.x) < 40) {
                let hit = false;
                if (Math.abs(this.turkey.y - obs.y) < 30) {
                    // Check if the turkey is jumping high enough to clear the obstacle
                    // A simple check is that only 'rock' and 'fence' can be jumped over.
                    // If turkey is jumping AND obstacle is jumpable, collision is prevented.
                    if (this.turkey.isJumping && (obs.type === 'rock' || obs.type === 'fence')) {
                         // Safe because of jump
                    } else if (!this.turkey.isJumping && obs.type === 'tree') {
                        // Trees are tall and cannot be jumped over. They must be avoided by lane change.
                        hit = true;
                    } else if (this.turkey.isJumping && obs.type === 'tree') {
                        // Even with a jump, a tree is too tall to clear by just changing lanes
                         hit = true; 
                    } else if (!this.turkey.isJumping && (obs.type === 'rock' || obs.type === 'fence')) {
                         // Cannot jump over if not jumping
                         hit = true;
                    }
                }
                if (hit) {
                    obs.hit = true;
                    this.hitObstacle();
                }
            }

            if (obs.x < -50) this.obstacles.splice(i, 1);
        }
    },

    hitObstacle: function() {
        AudioSys.playCrash();
        this.lives--;
        this.updateHearts();
        
        const container = document.getElementById('game-container');
        container.style.transform = 'translate(10px, 0)';
        setTimeout(() => container.style.transform = 'translate(0,0)', 100);

        if (this.lives <= 0) {
            this.state = 'FAIL';
            AudioSys.playGameOver();
            document.getElementById('fail-overlay').style.display = 'flex';
        }
    },

    completeRound: function() {
        this.state = 'MATH';
        this.currentDisguiseIndex++;
        document.getElementById('score-val').textContent = this.currentDisguiseIndex;
        
        if (this.currentDisguiseIndex >= 5) {
            this.winGame();
        } else {
            AudioSys.playCorrect();
            setTimeout(() => this.startMathPhase(), 1000);
        }
    },

    winGame: function() {
        AudioSys.playWin();
        const timeStr = this.timerEnabled ? `<p>Total Time: ${this.formatTime(this.elapsedMs)}</p>` : '';
        
        document.getElementById('start-screen').style.display = 'flex';
        document.getElementById('start-screen').innerHTML = `
            <h1 class="title game-font" style="color:#68D391">MISSION COMPLETE!</h1>
            <div style="font-size: 80px;">ü§†</div>
            <p>Operation Disguise Complete!</p>
            <p>The turkey is safe from the dinner table.</p>
            ${timeStr}
            <button class="btn-primary" onclick="location.reload()">PLAY AGAIN</button>
        `;
    },

    draw: function() {
        ctx.clearRect(0, 0, this.width, this.height);

        if (this.state === 'RUN' || this.state === 'FAIL') {
            // Draw Lanes
            ctx.strokeStyle = "rgba(255,255,255,0.3)";
            ctx.lineWidth = 2;
            this.lanes.forEach(y => {
                ctx.beginPath();
                ctx.moveTo(0, y + 20);
                ctx.lineTo(this.width, y + 20);
                ctx.stroke();
            });

            // Draw Obstacles
            this.obstacles.forEach(obs => {
                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                let icon = 'üå≤'; 
                if (obs.type === 'rock') icon = 'ü™®'; 
                if (obs.type === 'fence') icon = 'üöß'; 
                
                ctx.globalAlpha = obs.hit ? 0.3 : 1.0;
                ctx.fillText(icon, obs.x, obs.y);
                ctx.globalAlpha = 1.0;
            });

            // Draw Turkey
            ctx.save();
            ctx.translate(this.turkey.x, this.turkey.y);
            
            if (!this.turkey.isJumping) {
                ctx.translate(0, Math.sin(this.frameCount * 0.2) * 5);
            }

            ctx.scale(-1, 1); 

            ctx.font = "40px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("ü¶É", 0, 0);

            if (this.currentDisguiseIndex > 0) ctx.fillText("üé©", 0, -25); // Hat
            if (this.currentDisguiseIndex > 1) ctx.fillText("üï∂Ô∏è", -5, -5); // Glasses
            if (this.currentDisguiseIndex > 2) ctx.fillText("üß•", 0, 15); // Coat
            if (this.currentDisguiseIndex > 3) ctx.fillText("üëû", 10, 25); // Shoes 
            if (this.currentDisguiseIndex > 3) ctx.fillText("üëû", -10, 25); // Shoes
            if (this.currentDisguiseIndex > 4) ctx.fillText("üíº", -20, 15); // Briefcase

            ctx.restore();
            
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            for(let i=0; i<5; i++) {
                let lx = (this.frameCount * 10 + i * 100) % this.width;
                ctx.fillRect(this.width - lx, this.height - 10, 40, 4);
            }
        }
    },

    gameLoop: function() {
        this.update();
        this.draw();
        gameLoopId = requestAnimationFrame(() => this.gameLoop());
    }
};

function startGame() {
    Game.init();
    Game.start();
}

function handleInput(e, action) {
    if (e && e.cancelable) e.preventDefault();
    if (e && e.stopPropagation) e.stopPropagation();

    if (Game.state !== 'RUN') return;
    if (action === 'up') Game.moveTurkey(-1);
    if (action === 'down') Game.moveTurkey(1);
    if (action === 'jump') Game.jumpTurkey();
}
</script>
</body>
</html>
