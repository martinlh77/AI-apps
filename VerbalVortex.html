<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Verbal Vortex - AI Generated</title>
   <style>
       * {
           margin: 0;
           padding: 0;
           box-sizing: border-box;
       }
       
       body {
           font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
           background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
           min-height: 100vh;
           display: flex;
           justify-content: center;
           align-items: center;
           padding: 20px;
       }
       
       .container {
           background: white;
           border-radius: 20px;
           box-shadow: 0 20px 60px rgba(0,0,0,0.3);
           max-width: 600px;
           width: 100%;
           padding: 40px;
           position: relative;
       }
       
       h1 {
           text-align: center;
           color: #333;
           margin-bottom: 10px;
           font-size: 2.5em;
       }
       
       .subtitle {
           text-align: center;
           color: #666;
           margin-bottom: 30px;
           font-style: italic;
       }
       
       .mode-toggle {
           display: flex;
           justify-content: center;
           gap: 10px;
           margin-bottom: 30px;
       }
       
       .mode-btn {
           padding: 10px 20px;
           border: 2px solid #667eea;
           background: white;
           color: #667eea;
           border-radius: 25px;
           cursor: pointer;
           transition: all 0.3s;
           font-weight: bold;
       }
       
       .mode-btn.active {
           background: #667eea;
           color: white;
       }
       
       .game-area {
           text-align: center;
           min-height: 300px;
           display: flex;
           flex-direction: column;
           justify-content: center;
       }
       
       .gibberish {
           font-size: 2.2em;
           font-weight: bold;
           color: #764ba2;
           margin-bottom: 30px;
           line-height: 1.4;
           text-transform: uppercase;
           letter-spacing: 2px;
           min-height: 100px;
           display: flex;
           align-items: center;
           justify-content: center;
           flex-wrap: wrap;
       }
       
       .category-tag {
           display: inline-block;
           background: #f0f0f0;
           padding: 8px 20px;
           border-radius: 20px;
           font-size: 1.1em;
           font-weight: bold;
           color: #555;
           margin-bottom: 20px;
       }
       
       .input-area {
           display: flex;
           flex-direction: column;
           gap: 15px;
       }
       
       input[type="text"] {
           padding: 15px;
           font-size: 1.2em;
           border: 3px solid #ddd;
           border-radius: 10px;
           text-align: center;
           transition: border-color 0.3s;
       }
       
       input[type="text"]:focus {
           outline: none;
           border-color: #667eea;
       }
       
       input[type="text"]:disabled {
           background: #f0f0f0;
           cursor: not-allowed;
       }
       
       .btn-group {
           display: flex;
           gap: 10px;
           justify-content: center;
       }
       
       button {
           padding: 12px 30px;
           font-size: 1.1em;
           border: none;
           border-radius: 25px;
           cursor: pointer;
           transition: transform 0.2s, box-shadow 0.2s;
           font-weight: bold;
       }
       
       button:hover {
           transform: translateY(-2px);
           box-shadow: 0 5px 15px rgba(0,0,0,0.2);
       }
       
       button:disabled {
           opacity: 0.6;
           cursor: not-allowed;
           transform: none;
       }
       
       .submit-btn {
           background: #667eea;
           color: white;
       }
       
       .skip-btn {
           background: #ff6b6b;
           color: white;
       }
       
       .start-btn {
           background: #48bb78;
           color: white;
           font-size: 1.3em;
           padding: 15px 40px;
       }
       
       .feedback {
           margin-top: 20px;
           font-size: 1.2em;
           font-weight: bold;
           min-height: 30px;
       }
       
       .correct {
           color: #48bb78;
       }
       
       .incorrect {
           color: #ff6b6b;
       }
       
       .info-bar {
           display: flex;
           justify-content: space-between;
           margin-top: 20px;
           padding: 15px;
           background: #f7fafc;
           border-radius: 10px;
           font-weight: bold;
       }
       
       .timer {
           color: #e53e3e;
           font-size: 1.2em;
       }
       
       .loading {
           display: none;
           text-align: center;
           color: #667eea;
           font-style: italic;
       }
       
       .spinner {
           border: 4px solid #f3f3f3;
           border-top: 4px solid #667eea;
           border-radius: 50%;
           width: 40px;
           height: 40px;
           animation: spin 1s linear infinite;
           margin: 20px auto;
       }
       
       @keyframes spin {
           0% { transform: rotate(0deg); }
           100% { transform: rotate(360deg); }
       }
       
       .queue-status {
           font-size: 0.8em;
           color: #999;
           text-align: center;
           margin-top: 10px;
       }
       
       .hidden {
           display: none !important;
       }
   </style>
</head>
<body>
   <div class="container">
       <h1>üó£Ô∏è Verbal Vortex</h1>
       <p class="subtitle">It's not what you see, it's what you hear!</p>
       
       <div class="mode-toggle">
           <button class="mode-btn active" onclick="game.setMode('casual')">Casual (No Timer)</button>
           <button class="mode-btn" onclick="game.setMode('timed')">Timed (60s)</button>
       </div>
       
       <div id="startScreen" class="game-area">
           <p style="font-size: 1.2em; margin-bottom: 30px; color: #555;">
               I'll generate unique phrases using AI. Listen to the sounds, don't read the words!<br><br>
               <small style="color: #888;">(Don't worry about spelling - I understand typos!)</small>
           </p>
           <button class="start-btn" onclick="game.start()">Start Game</button>
           <div class="loading" id="initialLoading">
               <div class="spinner"></div>
               <p>Generating fresh phrases...</p>
           </div>
       </div>
       
       <div id="gameScreen" class="game-area hidden">
           <div class="category-tag" id="categoryDisplay">Category</div>
           <div class="gibberish" id="gibberishDisplay">Loading...</div>
           
           <div class="input-area">
               <input type="text" id="answerInput" placeholder="Type what you hear..." autocomplete="off">
               <div class="btn-group">
                   <button class="submit-btn" onclick="game.checkAnswer()">Submit</button>
                   <button class="skip-btn" id="skipBtn" onclick="game.skip()">Skip (-1)</button>
               </div>
           </div>
           
           <div class="feedback" id="feedback"></div>
           
           <div class="info-bar">
               <div>Score: <span id="score">0</span></div>
               <div id="timerDisplay" class="timer hidden">Time: <span id="timeLeft">60</span>s</div>
               <div>Streak: <span id="streak">0</span></div>
           </div>
           
           <div class="queue-status" id="queueStatus">Buffer: 0 phrases ready</div>
       </div>
       
       <div id="endScreen" class="game-area hidden">
           <h2 style="color: #764ba2; margin-bottom: 20px;">Game Over!</h2>
           <p style="font-size: 1.5em; margin-bottom: 20px;">Final Score: <span id="finalScore">0</span></p>
           <p style="margin-bottom: 30px; color: #666;">Phrases solved: <span id="solvedCount">0</span></p>
           <button class="start-btn" onclick="game.restart()">Play Again</button>
       </div>
   </div>

   <script>
       // API Configuration
       const API_KEY = 'pk_8CQPK8dxqANijjhy';
       const MODEL = 'nova-fast';
       const BATCH_SIZE = 10;
       
       class PhraseGenerator {
           constructor() {
               this.queue = [];
               this.usedAnswers = new Set();
               this.usedConcepts = new Set();
               this.generating = false;
           }
           
           async ensureBuffer() {
               if (this.queue.length < 3 && !this.generating) {
                   await this.generateBatch();
               }
           }
           
           async generateBatch() {
               this.generating = true;
               document.getElementById('queueStatus').textContent = 'Generating new phrases...';
               
               try {
                   const prompt = this.buildPrompt();
                   const seed = Math.floor(Math.random() * 1000000);
                   const url = `https://gen.pollinations.ai/text/${encodeURIComponent(prompt)}?model=${MODEL}&seed=${seed}&stream=false&key=${API_KEY}`;
                   
                   const response = await fetch(url);
                   const text = await response.text();
                   
                   // Parse JSON from response (handle potential markdown)
                   let jsonStr = text;
                   if (text.includes('```')) {
                       jsonStr = text.split('```')[1].replace('json', '');
                   }
                   
                   const phrases = JSON.parse(jsonStr);
                   
                   // Filter out any duplicates and add to queue
                   phrases.forEach(phrase => {
                       const normalized = phrase.answer.toLowerCase().trim();
                       if (!this.usedAnswers.has(normalized)) {
                           this.usedAnswers.add(normalized);
                           this.usedConcepts.add(phrase.category);
                           this.queue.push(phrase);
                       }
                   });
                   
               } catch (error) {
                   console.error('Generation error:', error);
                   // Fallback to prevent game breaking
                   if (this.queue.length === 0) {
                       this.queue.push({
                           gibberish: "Dew Knot Taper",
                           answer: "Do Not Stop Her",
                           category: "Common Phrase"
                       });
                   }
               }
               
               this.generating = false;
               this.updateStatus();
           }
           
           buildPrompt() {
               const usedList = Array.from(this.usedAnswers).slice(-20).join(', ');
               const categories = ['common phrases', 'movie titles', 'song lyrics', 'famous quotes', 'idioms', 'celebrity names', 'everyday objects', 'brand names', 'historical figures', 'book titles'];
               
               const shuffled = categories.sort(() => 0.5 - Math.random());
               const focusCategories = shuffled.slice(0, 3).join(', ');

               return `Generate ${BATCH_SIZE} Mad Gab puzzles. In Mad Gab, when you say the gibberish words quickly, they must sound EXACTLY like the target answer.

LINGUISTIC RULES (Phonetics, NOT Spelling):
1. SYLLABLE COUNT MUST MATCH: If the answer has 3 syllables, the gibberish must have exactly 3 syllables.
2. SOUND MAPPING: Each gibberish word must map to the sounds (phonemes) of the answer, ignoring spelling.
3. ALLOWED SOUND SHIFTS (like historical language change):
   - VOWEL SHIFTS: "ah" ‚Üî "uh" (stressed/unstressed), "ih" ‚Üî "ee", "oh" ‚Üî "aw"
   - CONSONANT SHIFTS (voiced/voiceless pairs): "k" ‚Üî "g", "t" ‚Üî "d", "p" ‚Üî "b", "f" ‚Üî "v", "s" ‚Üî "z"
   - LIQUIDS: "r" ‚Üî "l" (rhotic shift)
   - FINAL CONSONANTS: Often dropped or softened (t/d at end of words)
4. NO SILENT LETTERS: If the spelling has a silent letter (like G in "Ghetto"), you CANNOT use that word because the player will pronounce the G.

CORRECT EXAMPLES (Say them aloud fast):
- "Dew Wino" = "Do I Know" (Dew=Do, Wino=I Know)
- "Shore Ache" = "Sure H" (Shore=Sure, Ache=H) 
- "Knee Coat" = "Nicole" (Knee=Ni, Coat=Cole)
- "Wand Ear" = "Wonder" (Wand=Won, Ear=der)
- "Eye Mull I'd" = "I'm All I'd" (Eye=I'm, Mull=All, I'd=I'd - note: D is pronounced)
- "Thick Curl Oats All" = "The Colossal" (Thick=The, Curl=Col, Oats=oss, All=al)
- "Dime Owed" = "Time Out" (Dime=Time, Owed=Out - vowel shift)
- "Stir Ring" = "Starring" (Stir=Star, Ring=ring)
- "Abe Odd Hull" = "A Bottle" (Abe=A, Odd=Bo, Hull=ttle - final ll sounds like l)
- "Thesis Dan" = "The Sedan" (Thesis=The Se, Dan=dan)
- "Coat Tore" = "Go to Door" (Coat=Go, Tore=Door - k/g shift, t/d shift)

WRONG EXAMPLES (Do NOT do these - Spelling ‚â† Sound):
- "Beet Root See" ‚Üí "Better Times" (completely different sounds)
- "Eel Oil On" ‚Üí "Oil on Wheels" (makes no phonetic sense)
- "Eye Mull Ghetto" ‚Üí "I'm Alright Oh" (G is silent in Ghetto but player will say it; also not a real phrase)
- "Gin Run Nut" ‚Üí "Rings Around The Sun" (wrong syllable count, wrong sounds)

Your task: Pick phrases from these categories: ${focusCategories}. Break them into common English words that match the phonetics exactly when spoken rapidly. Test by reading aloud: does it sound like the answer?

Format: [{"gibberish": "Dew Knot", "answer": "Do Not", "category": "Common Phrase"}]

Already used (avoid these): ${usedList || 'none yet'}

Return ONLY valid JSON array. No markdown, no explanation. Verify each puzzle by speaking it aloud before including.`;
           }
           
           getNext() {
               if (this.queue.length === 0) return null;
               const phrase = this.queue.shift();
               this.ensureBuffer();
               this.updateStatus();
               return phrase;
           }
           
           updateStatus() {
               const status = document.getElementById('queueStatus');
               if (status) {
                   status.textContent = `Buffer: ${this.queue.length} phrases ready`;
               }
           }
           
           peekConcepts() {
               return Array.from(this.usedConcepts).slice(-10);
           }
       }
       
       class FuzzyMatcher {
           static normalize(str) {
               return str.toLowerCase()
                   .replace(/[^a-z0-9\s]/g, '')
                   .replace(/\s+/g, ' ')
                   .trim();
           }
           
           // Enhanced phonetic matching
           static phoneticEncode(str) {
               // Simple Soundex-like encoding for better matching
               return this.normalize(str)
                   .replace(/[ckq]/g, 'k')  // k sounds
                   .replace(/[gj]/g, 'g')   // g sounds
                   .replace(/[td]/g, 't')   // t/d sounds
                   .replace(/[bp]/g, 'b')   // b/p sounds
                   .replace(/[fv]/g, 'f')   // f/v sounds
                   .replace(/[sz]/g, 's')   // s/z sounds
                   .replace(/[mn]/g, 'n')   // nasal sounds often confused
                   .replace(/[lr]/g, 'l')   // liquids often shifted
                   .replace(/[aeiouy]+/g, 'a') // collapse vowels
                   .replace(/wh/g, 'w')
                   .replace(/ph/g, 'f');
           }
           
           static levenshteinDistance(s1, s2) {
               const matrix = [];
               for (let i = 0; i <= s2.length; i++) {
                   matrix[i] = [i];
               }
               for (let j = 0; j <= s1.length; j++) {
                   matrix[0][j] = j;
               }
               for (let i = 1; i <= s2.length; i++) {
                   for (let j = 1; j <= s1.length; j++) {
                       if (s2.charAt(i-1) === s1.charAt(j-1)) {
                           matrix[i][j] = matrix[i-1][j-1];
                       } else {
                           matrix[i][j] = Math.min(
                               matrix[i-1][j-1] + 1,
                               matrix[i][j-1] + 1,
                               matrix[i-1][j] + 1
                           );
                       }
                   }
               }
               return matrix[s2.length][s1.length];
           }
           
           static isSimilar(input, target) {
               const normInput = this.normalize(input);
               const normTarget = this.normalize(target);
               
               if (normInput === normTarget) return true;
               
               // Try phonetic matching
               const phonInput = this.phoneticEncode(input);
               const phonTarget = this.phoneticEncode(target);
               
               if (phonInput === phonTarget) return true;
               
               // Allow for minor typos based on length
               const maxDistance = Math.floor(normTarget.length * 0.3); // 30% tolerance
               const distance = this.levenshteinDistance(normInput, normTarget);
               
               // Also check phonetic distance
               const phonDistance = this.levenshteinDistance(phonInput, phonTarget);
               const maxPhonDistance = Math.floor(phonTarget.length * 0.25);
               
               return distance <= maxDistance || phonDistance <= maxPhonDistance;
           }
       }
       
       class Game {
           constructor() {
               this.generator = new PhraseGenerator();
               this.score = 0;
               this.streak = 0;
               this.mode = 'casual';
               this.timer = null;
               this.timeLeft = 60;
               this.currentPhrase = null;
               this.solvedCount = 0;
               this.isPlaying = false;
           }
           
           setMode(mode) {
               this.mode = mode;
               document.querySelectorAll('.mode-btn').forEach(btn => {
                   btn.classList.toggle('active', 
                       (mode === 'casual' && btn.textContent.includes('Casual')) ||
                       (mode === 'timed' && btn.textContent.includes('Timed'))
                   );
               });
           }
           
           async start() {
               document.getElementById('startScreen').classList.add('hidden');
               document.getElementById('initialLoading').style.display = 'block';
               
               await this.generator.generateBatch();
               
               document.getElementById('initialLoading').style.display = 'none';
               document.getElementById('gameScreen').classList.remove('hidden');
               
               if (this.mode === 'timed') {
                   document.getElementById('timerDisplay').classList.remove('hidden');
                   this.startTimer();
               }
               
               this.isPlaying = true;
               this.nextPhrase();
           }
           
           startTimer() {
               this.timeLeft = 60;
               this.updateTimerDisplay();
               this.timer = setInterval(() => {
                   this.timeLeft--;
                   this.updateTimerDisplay();
                   if (this.timeLeft <= 0) {
                       this.endGame();
                   }
               }, 1000);
           }
           
           updateTimerDisplay() {
               document.getElementById('timeLeft').textContent = this.timeLeft;
           }
           
           nextPhrase() {
               this.currentPhrase = this.generator.getNext();
               if (!this.currentPhrase) {
                   document.getElementById('gibberishDisplay').textContent = "Generating...";
                   setTimeout(() => this.nextPhrase(), 1000);
                   return;
               }
               
               document.getElementById('gibberishDisplay').textContent = this.currentPhrase.gibberish;
               document.getElementById('categoryDisplay').textContent = this.currentPhrase.category;
               document.getElementById('answerInput').value = '';
               document.getElementById('feedback').textContent = '';
               document.getElementById('answerInput').disabled = false;
               document.getElementById('answerInput').focus();
               document.getElementById('skipBtn').disabled = false;
               
               this.generator.ensureBuffer();
           }
           
           checkAnswer() {
               if (!this.isPlaying || !this.currentPhrase) return;
               
               const input = document.getElementById('answerInput').value;
               if (!input.trim()) return;
               
               const isCorrect = FuzzyMatcher.isSimilar(input, this.currentPhrase.answer);
               
               if (isCorrect) {
                   this.handleCorrect();
               } else {
                   this.handleIncorrect();
               }
           }
           
           handleCorrect() {
               this.score += 10 + (this.streak * 2);
               this.streak++;
               this.solvedCount++;
               this.updateStats();
               
               document.getElementById('feedback').innerHTML = 
                   `<span class="correct">‚úì Correct! "${this.currentPhrase.answer}"</span>`;
               
               setTimeout(() => this.nextPhrase(), 1500);
           }
           
           handleIncorrect() {
               this.streak = 0;
               this.updateStats();
               document.getElementById('feedback').innerHTML = 
                   `<span class="incorrect">‚úó Not quite... Keep trying!</span>`;
               
               const input = document.getElementById('answerInput');
               input.style.borderColor = '#ff6b6b';
               setTimeout(() => {
                   input.style.borderColor = '#ddd';
               }, 500);
           }
           
           skip() {
               if (!this.isPlaying || !this.currentPhrase) return;
               
               this.score = Math.max(0, this.score - 1);
               this.streak = 0;
               this.updateStats();
               
               document.getElementById('answerInput').disabled = true;
               document.getElementById('skipBtn').disabled = true;
               
               document.getElementById('feedback').innerHTML = 
                   `<span style="color: #667eea; font-size: 1.3em;">‚è≠Ô∏è Skipped!<br>The answer was: "<strong>${this.currentPhrase.answer}</strong>"</span>`;
               
               setTimeout(() => {
                   this.nextPhrase();
               }, 3000);
           }
           
           updateStats() {
               document.getElementById('score').textContent = this.score;
               document.getElementById('streak').textContent = this.streak;
           }
           
           endGame() {
               this.isPlaying = false;
               clearInterval(this.timer);
               
               document.getElementById('gameScreen').classList.add('hidden');
               document.getElementById('endScreen').classList.remove('hidden');
               document.getElementById('finalScore').textContent = this.score;
               document.getElementById('solvedCount').textContent = this.solvedCount;
           }
           
           restart() {
               this.score = 0;
               this.streak = 0;
               this.solvedCount = 0;
               this.generator = new PhraseGenerator();
               
               document.getElementById('endScreen').classList.add('hidden');
               document.getElementById('startScreen').classList.remove('hidden');
               document.getElementById('timerDisplay').classList.add('hidden');
               this.updateStats();
           }
       }
       
       const game = new Game();
       
       document.getElementById('answerInput').addEventListener('keypress', (e) => {
           if (e.key === 'Enter') game.checkAnswer();
       });
       
       document.addEventListener('keydown', (e) => {
           if (e.code === 'Space' && document.activeElement !== document.getElementById('answerInput')) {
               e.preventDefault();
           }
       });
   </script>
</body>
</html>
