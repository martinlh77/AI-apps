<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Combiner - Merge Videos Locally</title>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
      max-width: 900px; 
      margin: 40px auto; 
      padding: 20px;
      background: #f5f5f5;
    }
    .container { 
      background: white; 
      padding: 30px; 
      border-radius: 12px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h2 { margin-top: 0; color: #333; }
    
    /* Input Section */
    .input-section {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      border: 2px dashed #ddd;
    }
    
    .input-type-selector { 
      display: flex; 
      gap: 10px; 
      margin-bottom: 15px; 
    }
    .input-type-selector button { 
      flex: 1; 
      padding: 12px;
      background: white;
      border: 2px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    .input-type-selector button.active { 
      background: #007cba; 
      color: white; 
      border-color: #007cba;
    }
    
    .input-panel { display: none; }
    .input-panel.active { display: block; }
    
    input[type="file"], input[type="url"] {
      width: 100%;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-sizing: border-box;
      margin: 5px 0;
    }
    
    /* Video Queue / Playlist */
    #videoQueue {
      margin: 25px 0;
      min-height: 100px;
    }
    
    .queue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .video-count {
      font-size: 0.9em;
      color: #666;
      font-weight: 500;
    }
    
    .video-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .video-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 15px;
      background: white;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      cursor: move;
      transition: all 0.2s;
      position: relative;
    }
    
    .video-item:hover {
      border-color: #007cba;
      box-shadow: 0 2px 8px rgba(0,124,186,0.1);
    }
    
    .video-item.dragging {
      opacity: 0.5;
      border-color: #007cba;
      background: #e8f4f8;
    }
    
    .drag-handle {
      color: #999;
      font-size: 20px;
      cursor: grab;
      user-select: none;
    }
    
    .drag-handle:active { cursor: grabbing; }
    
    .video-thumb {
      width: 80px;
      height: 60px;
      object-fit: cover;
      border-radius: 4px;
      background: #000;
    }
    
    .video-info {
      flex: 1;
      min-width: 0;
    }
    
    .video-name {
      font-weight: 500;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 4px;
    }
    
    .video-meta {
      font-size: 0.85em;
      color: #666;
    }
    
    .video-res {
      display: inline-block;
      background: #e8f4f8;
      padding: 2px 8px;
      border-radius: 4px;
      margin-right: 8px;
      font-size: 0.85em;
    }
    
    .remove-btn {
      background: #dc3545;
      color: white;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    
    .remove-btn:hover { background: #c82333; }
    
    .empty-state {
      text-align: center;
      padding: 40px;
      color: #999;
      border: 2px dashed #ddd;
      border-radius: 8px;
      background: #fafafa;
    }
    
    /* Settings */
    .settings-panel {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    
    .setting-row {
      display: flex;
      gap: 20px;
      margin: 15px 0;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .setting-label {
      font-weight: 500;
      color: #333;
      min-width: 120px;
    }
    
    select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      background: white;
    }
    
    .info-text {
      font-size: 0.85em;
      color: #666;
      margin-left: 10px;
    }
    
    /* Action Button */
    .combine-btn {
      width: 100%;
      padding: 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    .combine-btn:hover:not(:disabled) { background: #218838; }
    .combine-btn:disabled { 
      background: #ccc; 
      cursor: not-allowed;
    }
    
    /* Progress & Status */
    .progress-container {
      display: none;
      margin: 20px 0;
    }
    
    .progress-container.active { display: block; }
    
    .progress-bar {
      width: 100%;
      height: 30px;
      background: #e0e0e0;
      border-radius: 15px;
      overflow: hidden;
      position: relative;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #007cba, #00a8e8);
      width: 0%;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 14px;
    }
    
    .status {
      margin-top: 10px;
      padding: 12px;
      border-radius: 6px;
      display: none;
      font-size: 0.95em;
    }
    
    .status.active { display: block; }
    .status.info { background: #e8f4f8; border-left: 4px solid #007cba; }
    .status.success { background: #d4edda; border-left: 4px solid #28a745; }
    .status.error { background: #f8d7da; border-left: 4px solid #dc3545; }
    
    .spinner {
      display: none;
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #007cba;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    
    .spinner.active { display: block; }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Preview Section */
    #previewSection {
      display: none;
      margin-top: 30px;
      padding-top: 30px;
      border-top: 2px solid #e0e0e0;
    }
    
    #previewSection.active { display: block; }
    
    #resultVideo {
      width: 100%;
      max-height: 500px;
      border-radius: 8px;
      background: #000;
      margin-bottom: 15px;
    }
    
    .download-btn {
      display: inline-block;
      width: 100%;
      padding: 14px;
      background: #007cba;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      text-align: center;
      font-weight: 500;
      box-sizing: border-box;
    }
    
    .download-btn:hover { background: #005a87; }
    
    .warning {
      background: #fff3cd;
      padding: 12px;
      border-radius: 6px;
      margin: 15px 0;
      font-size: 0.9em;
      border-left: 4px solid #ffc107;
      color: #856404;
    }
    
    /* Responsive */
    @media (max-width: 600px) {
      .setting-row { flex-direction: column; align-items: flex-start; gap: 8px; }
      .video-item { padding: 10px; }
      .video-thumb { width: 60px; height: 45px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üé¨ Video Combiner</h2>
    <p style="color: #666; margin-top: -10px;">Merge multiple videos into one. All processing happens locally in your browser.</p>
    
    <div class="warning">
      ‚ö†Ô∏è <strong>Privacy First:</strong> Videos are processed entirely on your device and never uploaded to any server.
    </div>
    
    <!-- Input Section -->
    <div class="input-section">
      <div class="input-type-selector">
        <button type="button" class="active" onclick="switchInputType('file')">üìÅ Upload Files</button>
        <button type="button" onclick="switchInputType('url')">üîó Add from URL</button>
      </div>
      
      <div id="filePanel" class="input-panel active">
        <input type="file" id="fileInput" accept="video/*" multiple onchange="handleFileSelect(event)">
        <small style="color: #666;">Hold Ctrl/Cmd to select multiple files</small>
      </div>
      
      <div id="urlPanel" class="input-panel">
        <input type="url" id="urlInput" placeholder="https://example.com/video.mp4">
        <button type="button" onclick="addVideoFromUrl()" style="margin-top: 8px; width: 100%; padding: 10px; background: #007cba; color: white; border: none; border-radius: 6px; cursor: pointer;">
          Add Video from URL
        </button>
        <small style="color: #666; display: block; margin-top: 5px;">Note: URL must support CORS or be from the same domain</small>
      </div>
    </div>
    
    <!-- Video Queue -->
    <div id="videoQueue">
      <div class="queue-header">
        <span class="video-count" id="videoCount">No videos added</span>
        <button onclick="clearAll()" style="background: none; border: none; color: #dc3545; cursor: pointer; font-size: 0.9em;">Clear All</button>
      </div>
      <div id="videoList" class="video-list">
        <div class="empty-state">
          <div style="font-size: 3em; margin-bottom: 10px;">üì≠</div>
          <div>Add videos above to start combining</div>
        </div>
      </div>
    </div>
    
    <!-- Settings -->
    <div class="settings-panel">
      <h3 style="margin-top: 0; margin-bottom: 15px; font-size: 1.1em;">‚öôÔ∏è Output Settings</h3>
      
      <div class="setting-row">
        <span class="setting-label">Resolution:</span>
        <select id="resolutionSelect">
          <option value="1080">1080p (Full HD) - 1920√ó1080</option>
          <option value="720" selected>720p (HD) - 1280√ó720</option>
          <option value="480">480p (SD) - 854√ó480</option>
          <option value="360">360p - 640√ó360</option>
        </select>
        <span class="info-text">All videos will be scaled to fit this resolution while maintaining aspect ratio</span>
      </div>
      
      <div class="setting-row">
        <span class="setting-label">Frame Rate:</span>
        <select id="fpsSelect">
          <option value="60">60 fps (Smooth)</option>
          <option value="30" selected>30 fps (Standard)</option>
          <option value="24">24 fps (Cinematic)</option>
        </select>
        <span class="info-text">Output frame rate</span>
      </div>
      
      <div class="setting-row">
        <span class="setting-label">Aspect Ratio:</span>
        <select id="aspectSelect">
          <option value="maintain">Maintain original (letterbox if different)</option>
          <option value="stretch">Stretch to fill (may distort)</option>
          <option value="crop">Crop to fill (may cut edges)</option>
        </select>
      </div>
    </div>
    
    <!-- Combine Button -->
    <button class="combine-btn" id="combineBtn" onclick="combineVideos()" disabled>
      <span>üé¨</span>
      <span>Combine Videos</span>
    </button>
    
    <!-- Progress -->
    <div class="progress-container" id="progressContainer">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill">0%</div>
      </div>
      <div style="text-align: center; color: #666; margin-top: 8px; font-size: 0.9em;" id="progressText">Preparing...</div>
    </div>
    
    <div class="spinner" id="spinner"></div>
    <div class="status" id="status"></div>
    
    <!-- Preview Section -->
    <div id="previewSection">
      <h3 style="margin-bottom: 15px;">‚úÖ Combined Video</h3>
      <video id="resultVideo" controls></video>
      <a id="downloadLink" class="download-btn" download="combined-video.webm">
        ‚¨áÔ∏è Download Combined Video (WebM)
      </a>
      <div style="margin-top: 10px; font-size: 0.85em; color: #666; text-align: center;">
        Note: Safari users may need to use "Save Video As..." from the player context menu
      </div>
    </div>
  </div>

  <script>
    let videoQueue = [];
    let dragSrcEl = null;
    let isProcessing = false;
    
    // CORS Proxy for external URLs (using a public proxy - in production, use your own)
    const CORS_PROXIES = [
      'https://api.allorigins.win/raw?url=',
      'https://corsproxy.io/?'
    ];
    
    function switchInputType(type) {
      document.querySelectorAll('.input-type-selector button').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.toLowerCase().includes(type));
      });
      document.getElementById('filePanel').classList.toggle('active', type === 'file');
      document.getElementById('urlPanel').classList.toggle('active', type === 'url');
    }
    
    function handleFileSelect(event) {
      const files = Array.from(event.target.files);
      files.forEach(file => addVideoToQueue(file, file.name, URL.createObjectURL(file)));
      event.target.value = ''; // Reset input
    }
    
    async function addVideoFromUrl() {
      const urlInput = document.getElementById('urlInput');
      const url = urlInput.value.trim();
      if (!url) {
        showStatus('Please enter a valid URL', 'error');
        return;
      }
      
      showStatus('Loading video from URL...', 'info');
      
      try {
        // Try direct fetch first (works if CORS is enabled)
        let response;
        let blob;
        let usedProxy = false;
        
        try {
          response = await fetch(url);
          if (!response.ok) throw new Error('Direct fetch failed');
          blob = await response.blob();
        } catch (e) {
          // Try with CORS proxies
          for (const proxy of CORS_PROXIES) {
            try {
              response = await fetch(proxy + encodeURIComponent(url));
              if (response.ok) {
                blob = await response.blob();
                usedProxy = true;
                break;
              }
            } catch (err) {
              continue;
            }
          }
          if (!blob) throw new Error('Unable to fetch video. The server may block cross-origin requests.');
        }
        
        if (!blob.type.startsWith('video/')) {
          throw new Error('URL does not point to a valid video file');
        }
        
        const objectUrl = URL.createObjectURL(blob);
        const name = url.split('/').pop().split('?')[0] || 'video-from-url.mp4';
        addVideoToQueue(blob, name, objectUrl, usedProxy ? '(via CORS proxy)' : '');
        urlInput.value = '';
        showStatus('Video added successfully!', 'success');
      } catch (err) {
        showStatus('Error: ' + err.message, 'error');
        console.error(err);
      }
    }
    
    async function addVideoToQueue(fileOrBlob, name, objectUrl, extraInfo = '') {
      // Create video element to get metadata
      const video = document.createElement('video');
      video.preload = 'metadata';
      video.src = objectUrl;
      
      await new Promise((resolve, reject) => {
        video.onloadedmetadata = () => {
          if (video.duration === Infinity) {
            // Some browsers report Infinity for certain formats, seek to get real duration
            video.currentTime = 1e101;
            video.ontimeupdate = () => {
              video.ontimeupdate = null;
              resolve();
            };
          } else {
            resolve();
          }
        };
        video.onerror = () => reject(new Error('Failed to load video metadata'));
        setTimeout(() => reject(new Error('Timeout loading metadata')), 10000);
      });
      
      const duration = video.duration === Infinity ? 0 : video.duration;
      const width = video.videoWidth;
      const height = video.videoHeight;
      
      // Generate thumbnail
      video.currentTime = Math.min(1, duration / 2);
      await new Promise(r => video.onseeked = r);
      
      const canvas = document.createElement('canvas');
      canvas.width = 160;
      canvas.height = 120;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, 160, 120);
      const thumbnail = canvas.toDataURL('image/jpeg', 0.7);
      
      const videoItem = {
        id: Date.now() + Math.random(),
        file: fileOrBlob,
        name: name,
        url: objectUrl,
        duration: duration,
        width: width,
        height: height,
        thumbnail: thumbnail,
        extraInfo: extraInfo
      };
      
      videoQueue.push(videoItem);
      renderQueue();
      updateCombineButton();
    }
    
    function renderQueue() {
      const container = document.getElementById('videoList');
      const countEl = document.getElementById('videoCount');
      
      if (videoQueue.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div style="font-size: 3em; margin-bottom: 10px;">üì≠</div>
            <div>Add videos above to start combining</div>
          </div>
        `;
        countEl.textContent = 'No videos added';
        return;
      }
      
      countEl.textContent = `${videoQueue.length} video${videoQueue.length !== 1 ? 's' : ''} ‚Ä¢ Total duration: ${formatDuration(videoQueue.reduce((acc, v) => acc + v.duration, 0))}`;
      
      container.innerHTML = '';
      videoQueue.forEach((video, index) => {
        const item = document.createElement('div');
        item.className = 'video-item';
        item.draggable = true;
        item.dataset.index = index;
        
        item.innerHTML = `
          <div class="drag-handle">‚ãÆ‚ãÆ</div>
          <img class="video-thumb" src="${video.thumbnail}" alt="thumb">
          <div class="video-info">
            <div class="video-name">${escapeHtml(video.name)} ${video.extraInfo ? `<span style="color: #999; font-size: 0.9em;">${video.extraInfo}</span>` : ''}</div>
            <div class="video-meta">
              <span class="video-res">${video.width}√ó${video.height}</span>
              <span>${formatDuration(video.duration)}</span>
            </div>
          </div>
          <button class="remove-btn" onclick="removeVideo(${index})" title="Remove">√ó</button>
        `;
        
        // Drag events
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragenter', handleDragEnter);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('dragleave', handleDragLeave);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragend', handleDragEnd);
        
        container.appendChild(item);
      });
    }
    
    function handleDragStart(e) {
      this.style.opacity = '0.4';
      dragSrcEl = this;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.innerHTML);
      this.classList.add('dragging');
    }
    
    function handleDragOver(e) {
      if (e.preventDefault) e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      return false;
    }
    
    function handleDragEnter(e) {
      this.classList.add('dragging');
    }
    
    function handleDragLeave(e) {
      this.classList.remove('dragging');
    }
    
    function handleDrop(e) {
      if (e.stopPropagation) e.stopPropagation();
      if (dragSrcEl !== this) {
        const fromIndex = parseInt(dragSrcEl.dataset.index);
        const toIndex = parseInt(this.dataset.index);
        
        // Reorder array
        const item = videoQueue.splice(fromIndex, 1)[0];
        videoQueue.splice(toIndex, 0, item);
        
        renderQueue();
      }
      return false;
    }
    
    function handleDragEnd(e) {
      this.style.opacity = '1';
      document.querySelectorAll('.video-item').forEach(item => {
        item.classList.remove('dragging');
      });
    }
    
    function removeVideo(index) {
      const url = videoQueue[index].url;
      URL.revokeObjectURL(url);
      videoQueue.splice(index, 1);
      renderQueue();
      updateCombineButton();
      
      if (videoQueue.length === 0) {
        document.getElementById('previewSection').classList.remove('active');
      }
    }
    
    function clearAll() {
      videoQueue.forEach(v => URL.revokeObjectURL(v.url));
      videoQueue = [];
      renderQueue();
      updateCombineButton();
      document.getElementById('previewSection').classList.remove('active');
    }
    
    function updateCombineButton() {
      document.getElementById('combineBtn').disabled = videoQueue.length < 2 || isProcessing;
    }
    
    async function combineVideos() {
      if (videoQueue.length < 2) return;
      if (isProcessing) return;
      
      isProcessing = true;
      updateCombineButton();
      document.getElementById('previewSection').classList.remove('active');
      
      const resolution = parseInt(document.getElementById('resolutionSelect').value);
      const fps = parseInt(document.getElementById('fpsSelect').value);
      const aspectMode = document.getElementById('aspectSelect').value;
      
      // Calculate output dimensions (16:9 for standard, but we'll fit the first video's aspect ratio if maintain is selected)
      let targetWidth = resolution;
      let targetHeight = Math.round(resolution * 9 / 16); // Default 16:9
      
      if (aspectMode === 'maintain' && videoQueue.length > 0) {
        // Use the first video's aspect ratio as the container
        const firstVideo = videoQueue[0];
        const firstAspect = firstVideo.width / firstVideo.height;
        if (firstAspect > 1) {
          targetWidth = resolution;
          targetHeight = Math.round(resolution / firstAspect);
        } else {
          targetHeight = resolution;
          targetWidth = Math.round(resolution * firstAspect);
        }
      }
      
      showStatus('Initializing video processing...', 'info');
      document.getElementById('progressContainer').classList.add('active');
      document.getElementById('spinner').classList.add('active');
      
      try {
        // Setup canvas
        const canvas = document.createElement('canvas');
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext('2d');
        
        // Setup MediaRecorder
        const stream = canvas.captureStream(fps);
        const mimeTypes = [
          'video/webm;codecs=vp9',
          'video/webm;codecs=vp8',
          'video/webm',
          'video/mp4'
        ];
        
        let selectedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));
        if (!selectedMimeType) selectedMimeType = '';
        
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: selectedMimeType,
          videoBitsPerSecond: 5000000 // 5 Mbps
        });
        
        const chunks = [];
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) chunks.push(e.data);
        };
        
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: selectedMimeType || 'video/webm' });
          const url = URL.createObjectURL(blob);
          
          const video = document.getElementById('resultVideo');
          video.src = url;
          document.getElementById('downloadLink').href = url;
          document.getElementById('downloadLink').download = `combined-video.${selectedMimeType.includes('mp4') ? 'mp4' : 'webm'}`;
          
          document.getElementById('previewSection').classList.add('active');
          document.getElementById('previewSection').scrollIntoView({ behavior: 'smooth' });
          
          showStatus('‚úÖ Videos combined successfully!', 'success');
          document.getElementById('progressContainer').classList.remove('active');
          document.getElementById('spinner').classList.remove('active');
          isProcessing = false;
          updateCombineButton();
        };
        
        mediaRecorder.start();
        
        let totalDuration = videoQueue.reduce((acc, v) => acc + v.duration, 0);
        let processedDuration = 0;
        
        // Process each video
        for (let i = 0; i < videoQueue.length; i++) {
          const videoData = videoQueue[i];
          await processVideoSegment(videoData, canvas, ctx, mediaRecorder, fps, targetWidth, targetHeight, aspectMode, (progress) => {
            const segmentProgress = progress * videoData.duration;
            const currentTotal = processedDuration + segmentProgress;
            const percent = (currentTotal / totalDuration) * 100;
            updateProgress(percent, `Processing video ${i + 1} of ${videoQueue.length}...`);
          });
          processedDuration += videoData.duration;
        }
        
        mediaRecorder.stop();
        
      } catch (err) {
        console.error(err);
        showStatus('Error: ' + err.message, 'error');
        document.getElementById('progressContainer').classList.remove('active');
        document.getElementById('spinner').classList.remove('active');
        isProcessing = false;
        updateCombineButton();
      }
    }
    
    async function processVideoSegment(videoData, canvas, ctx, recorder, fps, targetW, targetH, aspectMode, onProgress) {
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.src = videoData.url;
        video.muted = true; // Important for autoplay
        video.playsInline = true;
        video.playbackRate = 1;
        
        let frameInterval;
        let nextFrameTime;
        
        const drawFrame = () => {
          if (video.paused || video.ended) return;
          
          // Calculate scaling based on aspect mode
          let drawX = 0, drawY = 0, drawW = targetW, drawH = targetH;
          
          if (aspectMode === 'maintain') {
            // Letterbox: fit within target maintaining aspect ratio
            const videoAspect = videoData.width / videoData.height;
            const targetAspect = targetW / targetH;
            
            if (videoAspect > targetAspect) {
              drawW = targetW;
              drawH = targetW / videoAspect;
              drawY = (targetH - drawH) / 2;
            } else {
              drawH = targetH;
              drawW = targetH * videoAspect;
              drawX = (targetW - drawW) / 2;
            }
            
            // Clear background (black bars)
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, targetW, targetH);
          } else if (aspectMode === 'crop') {
            // Crop to fill
            const videoAspect = videoData.width / videoData.height;
            const targetAspect = targetW / targetH;
            
            let renderW, renderH, srcX, srcY, srcW, srcH;
            if (videoAspect > targetAspect) {
              // Video is wider: crop sides
              renderH = videoData.height;
              renderW = videoData.height * targetAspect;
              srcX = (videoData.width - renderW) / 2;
              srcY = 0;
              srcW = renderW;
              srcH = renderH;
            } else {
              // Video is taller: crop top/bottom
              renderW = videoData.width;
              renderH = videoData.width / targetAspect;
              srcX = 0;
              srcY = (videoData.height - renderH) / 2;
              srcW = renderW;
              srcH = renderH;
            }
            
            ctx.drawImage(video, srcX, srcY, srcW, srcH, 0, 0, targetW, targetH);
            
            if (video.currentTime < video.duration) {
              onProgress(video.currentTime / video.duration);
              requestAnimationFrame(drawFrame);
            }
            return;
          }
          // stretch mode uses full canvas automatically
          
          ctx.drawImage(video, drawX, drawY, drawW, drawH);
          
          if (video.currentTime < video.duration) {
            onProgress(video.currentTime / video.duration);
            requestAnimationFrame(drawFrame);
          }
        };
        
        video.onplay = () => {
          drawFrame();
        };
        
        video.onended = () => {
          resolve();
        };
        
        video.onerror = () => {
          reject(new Error(`Failed to load video: ${videoData.name}`));
        };
        
        video.play().catch(reject);
      });
    }
    
    function updateProgress(percent, text) {
      const fill = document.getElementById('progressFill');
      const textEl = document.getElementById('progressText');
      fill.style.width = Math.min(100, Math.max(0, percent)) + '%';
      fill.textContent = Math.round(percent) + '%';
      if (text) textEl.textContent = text;
    }
    
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + type + ' active';
      if (type === 'success' || type === 'error') {
        setTimeout(() => {
          if (type === 'error') status.classList.remove('active');
        }, 5000);
      }
    }
    
    function formatDuration(seconds) {
      if (!seconds || seconds === Infinity) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Initialize
    showStatus('Ready! Add at least 2 videos to combine.', 'info');
  </script>
</body>
</html>
