<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Workflow Studio</title>
    <!-- Same FFmpeg files as VideoCombine.html -->
    <script src="https://martinlh77.github.io/AI-apps/tools/ffmpeg/ffmpeg.js"></script>
    <script src="https://martinlh77.github.io/AI-apps/tools/ffmpeg/index.js"></script>
    <style>
        :root {
            --bg: #0f172a;
            --surface: #1e293b;
            --surface-hover: #334155;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
            --border: #475569;
            --primary: #6366f1;
            --primary-hover: #4f46e5;
            --success: #22c55e;
            --error: #ef4444;
            --warning: #f59e0b;
            --radius: 0.75rem;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
        }
        [data-theme="light"] {
            --bg: #f8fafc;
            --surface: #ffffff;
            --surface-hover: #f1f5f9;
            --text: #0f172a;
            --text-muted: #64748b;
            --border: #cbd5e1;
            --primary: #4f46e5;
            --primary-hover: #4338ca;
        }
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 1rem; }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        h1 { margin: 0; font-size: 1.5rem; color: var(--primary); }
        .controls { display: flex; gap: 0.5rem; align-items: center; }
        button, .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        button:hover, .btn:hover { background: var(--primary-hover); transform: translateY(-1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        button.secondary { background: var(--surface-hover); }
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
        }
        .tab {
            padding: 0.75rem 1.5rem;
            background: none;
            color: var(--text-muted);
            border-radius: var(--radius) var(--radius) 0 0;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            white-space: nowrap;
            cursor: pointer;
            border: none;
        }
        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: var(--surface);
        }
        .panel { display: none; }
        .panel.active { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }
        .grid { display: grid; gap: 1rem; }
        .grid-2 { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
        label { display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; }
        input[type="text"], input[type="url"], input[type="password"], input[type="number"], textarea, select {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-family: inherit;
            font-size: 0.95rem;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        textarea { resize: vertical; min-height: 100px; }
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg);
        }
        .upload-zone:hover { border-color: var(--primary); background: rgba(99, 102, 241, 0.05); }
        .image-preview {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        .preview-item {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: var(--radius);
            overflow: hidden;
            border: 2px solid var(--border);
        }
        .preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .preview-item .remove {
            position: absolute;
            top: 4px;
            right: 4px;
            background: var(--error);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
        }
        .video-player {
            width: 100%;
            max-height: 500px;
            border-radius: var(--radius);
            background: #000;
            margin: 1rem 0;
        }
        .history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        .history-item {
            position: relative;
            background: var(--bg);
            border-radius: var(--radius);
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .history-item:hover { border-color: var(--primary); transform: scale(1.02); }
        .history-item img, .history-item video {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
        }
        .history-meta {
            padding: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .history-actions {
            position: absolute;
            top: 4px;
            right: 4px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .history-item:hover .history-actions { opacity: 1; }
        .icon-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
        .icon-btn:hover { background: var(--primary); }
        .queue-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            margin-bottom: 0.5rem;
            border: 1px solid var(--border);
            cursor: move;
        }
        .queue-item.dragging { opacity: 0.5; border-color: var(--primary); }
        .queue-thumb { width: 80px; height: 60px; object-fit: cover; border-radius: 0.5rem; background: #000; }
        .queue-info { flex: 1; min-width: 0; }
        .queue-title { font-weight: 500; margin-bottom: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .queue-meta { font-size: 0.85rem; color: var(--text-muted); }
        .progress-container {
            margin: 1rem 0;
            display: none;
        }
        .progress-bar {
            height: 30px;
            background: var(--bg);
            border-radius: var(--radius);
            overflow: hidden;
            position: relative;
            border: 1px solid var(--border);
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), #818cf8);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .status {
            padding: 1rem;
            border-radius: var(--radius);
            margin: 1rem 0;
            display: none;
        }
        .status.active { display: block; }
        .status.info { background: rgba(99, 102, 241, 0.1); border-left: 4px solid var(--primary); }
        .status.success { background: rgba(34, 197, 94, 0.1); border-left: 4px solid var(--success); }
        .status.error { background: rgba(239, 68, 68, 0.1); border-left: 4px solid var(--error); }
        .frame-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin: 1rem 0;
            flex-wrap: wrap;
        }
        canvas.frame-canvas {
            max-width: 100%;
            border-radius: var(--radius);
            border: 2px solid var(--border);
            background: #000;
        }
        .hidden { display: none !important; }
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: var(--surface);
            border-radius: var(--radius);
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 1.5rem;
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        @media (max-width: 768px) {
            .grid-2 { grid-template-columns: 1fr; }
            .queue-item { flex-direction: column; text-align: center; }
            .queue-thumb { width: 100%; height: auto; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé¨ Video Workflow Studio</h1>
            <div class="controls">
                <button onclick="toggleTheme()" title="Toggle Dark/Light Mode">
                    <span id="themeIcon">‚òÄÔ∏è</span>
                </button>
                <button onclick="showApiKeyModal()" class="secondary">üîë API Key</button>
            </div>
        </header>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('generate')">üé® Generate</button>
            <button class="tab" onclick="switchTab('extract')">üì∏ Extract</button>
            <button class="tab" onclick="switchTab('combine')">üé¨ Combine</button>
            <button class="tab" onclick="switchTab('history')">üìö History</button>
        </div>
        
        <!-- Generate Panel -->
        <div id="generatePanel" class="panel active">
            <div class="card">
                <div class="grid grid-2">
                    <div>
                        <label>Prompt (max 500 chars)</label>
                        <textarea id="promptInput" placeholder="Describe the video..." maxlength="500"></textarea>
                        <div style="text-align: right; font-size: 0.85rem; color: var(--text-muted); margin-top: 0.25rem;">
                            <span id="charCount">0</span>/500
                        </div>
                        
                        <label style="margin-top: 1rem;">Mode</label>
                        <select id="grokMode">
                            <option value="normal">Normal</option>
                            <option value="spicy">Spicy</option>
                            <option value="fun">Fun</option>
                        </select>
                        
                        <label style="margin-top: 1rem;">Aspect Ratio</label>
                        <select id="grokAspectRatio">
                            <option value="2:3">2:3 Portrait</option>
                            <option value="3:2">3:2 Landscape</option>
                            <option value="1:1">1:1 Square</option>
                        </select>
                        
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg); border-radius: var(--radius); font-size: 0.9rem; color: var(--text-muted);">
                            ‚ÑπÔ∏è Max 2 images. Images auto-upload to AnonDrop (required).
                        </div>
                    </div>
                    
                    <div>
                        <label>Reference Images (Optional, max 2)</label>
                        <div class="upload-zone" onclick="document.getElementById('imageUpload').click()" id="dropZone">
                            <div>üìÅ Click or drag images here</div>
                            <input type="file" id="imageUpload" accept="image/*" multiple style="display: none;" onchange="handleImageSelect(event)">
                        </div>
                        
                        <div id="imagePreviewContainer" class="image-preview"></div>
                        
                        <button onclick="generateVideo()" id="generateBtn" style="width: 100%; margin-top: 1rem; padding: 1rem; font-size: 1.1rem;">
                            <span id="genSpinner" class="spinner hidden"></span>
                            Generate Video
                        </button>
                        
                        <div id="generateStatus" class="status"></div>
                    </div>
                </div>
            </div>
            
            <div class="card" id="resultCard" style="display: none;">
                <h3>Generated Result</h3>
                <video id="resultVideo" class="video-player" controls loop></video>
                <div style="display: flex; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap;">
                    <button onclick="downloadCurrentVideo()" class="btn">‚¨áÔ∏è Download</button>
                    <button onclick="addToCombineFromCurrent()" class="btn secondary">‚ûï Add to Combine</button>
                    <button onclick="extractFromCurrent()" class="btn secondary">‚úÇÔ∏è Extract Frames</button>
                </div>
            </div>
        </div>
        
        <!-- Extract Panel -->
        <div id="extractPanel" class="panel">
            <div class="card">
                <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
                    <select id="extractSource" onchange="changeExtractSource()">
                        <option value="history">From History</option>
                        <option value="file">Upload File</option>
                        <option value="url">From URL</option>
                    </select>
                    <select id="historySelect" style="flex: 1; min-width: 200px;"></select>
                    <input type="file" id="extractFileInput" accept="video/*" style="display: none;" onchange="handleExtractFile(event)">
                    <input type="url" id="extractUrlInput" placeholder="https://example.com/video.mp4" style="display: none; flex: 1;">
                    <button id="extractLoadBtn" onclick="loadExtractVideo()" class="btn">Load Video</button>
                </div>
                
                <video id="extractVideo" class="video-player" controls style="display: none;"></video>
                
                <div id="extractControls" style="display: none;">
                    <div class="frame-controls">
                        <button onclick="seekFrame(-1)">‚èÆÔ∏è Frame</button>
                        <button onclick="seekFrame(1)">‚è≠Ô∏è Frame</button>
                        <button onclick="goToStart()">‚èπÔ∏è First</button>
                        <button onclick="goToEnd()">‚èèÔ∏è Last</button>
                        <button onclick="captureFrame()">üì∏ Capture</button>
                        <span id="timeDisplay" style="margin-left: auto; font-family: monospace;">00:00:00</span>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
                        <div>
                            <canvas id="frameCanvas" class="frame-canvas" width="640" height="360"></canvas>
                        </div>
                        <div>
                            <button onclick="extractSpecificFrame('first')" class="btn secondary" style="width: 100%; margin-bottom: 0.5rem;">üì• First Frame</button>
                            <button onclick="extractSpecificFrame('last')" class="btn secondary" style="width: 100%; margin-bottom: 0.5rem;">üì• Last Frame</button>
                            
                            <div id="uploadFrameSection" style="display: none; padding: 1rem; background: var(--bg); border-radius: var(--radius); margin-top: 1rem;">
                                <h4 style="margin-top: 0;">Upload to AnonDrop</h4>
                                <div id="frameUploadPreview" style="margin: 0.5rem 0;"></div>
                                <button onclick="uploadCapturedFrame()" id="uploadFrameBtn" class="btn" style="width: 100%;">‚òÅÔ∏è Get Link</button>
                                <div id="frameUploadResult" style="margin-top: 0.5rem; font-size: 0.9rem;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <label>Video Position</label>
                        <input type="range" id="videoSlider" min="0" max="100" step="0.1" value="0" style="width: 100%;" oninput="updateVideoFromSlider()">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Combine Panel -->
        <div id="combinePanel" class="panel">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;">
                    <h3 style="margin: 0;">Video Queue (Drag to reorder)</h3>
                    <div style="display: flex; gap: 0.5rem;">
                        <select id="addFromHistory"><option value="">Add from history...</option></select>
                        <button onclick="addSelectedToQueue()" class="btn secondary">Add</button>
                        <button onclick="clearQueue()" class="btn secondary">Clear</button>
                    </div>
                </div>
                
                <div id="videoQueue" style="min-height: 100px; margin-bottom: 1rem;">
                    <div style="text-align: center; padding: 2rem; color: var(--text-muted);">No videos in queue</div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                    <div>
                        <label>Resolution</label>
                        <select id="combineResolution">
                            <option value="original">Original</option>
                            <option value="1080" selected>1080p</option>
                            <option value="720">720p</option>
                            <option value="480">480p</option>
                        </select>
                    </div>
                    <div>
                        <label>Audio</label>
                        <select id="combineAudio">
                            <option value="keep" selected>Keep audio</option>
                            <option value="mute">Mute</option>
                        </select>
                    </div>
                </div>
                
                <button onclick="combineVideos()" id="combineBtn" class="btn" style="width: 100%; padding: 1rem; font-size: 1.1rem;" disabled>
                    üé¨ Combine Videos
                </button>
                
                <div id="combineProgress" class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="combineProgressFill" style="width: 0%">0%</div>
                    </div>
                    <div id="combineStatusText" style="text-align: center; margin-top: 0.5rem; color: var(--text-muted);">Initializing...</div>
                </div>
                
                <div id="combineResult" style="display: none; margin-top: 1rem;">
                    <video id="combinedVideo" class="video-player" controls></video>
                    <a id="combinedDownload" class="btn" style="width: 100%; margin-top: 0.5rem; text-decoration: none; display: block; text-align: center;" download="combined.mp4">‚¨áÔ∏è Download Combined Video</a>
                </div>
            </div>
        </div>
        
        <!-- History Panel -->
        <div id="historyPanel" class="panel">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;">
                    <h3 style="margin: 0;">Generation History</h3>
                    <div>
                        <button onclick="exportHistory()" class="btn secondary" style="font-size: 0.85rem;">üì§ Export</button>
                        <button onclick="document.getElementById('importFile').click()" class="btn secondary" style="font-size: 0.85rem;">üì• Import</button>
                        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importHistory(event)">
                        <button onclick="clearHistory()" class="btn secondary" style="font-size: 0.85rem; margin-left: 0.5rem;">Clear</button>
                    </div>
                </div>
                <div id="historyGrid" class="history-grid"></div>
            </div>
        </div>
    </div>
    
    <!-- API Key Modal -->
    <div id="apiKeyModal" class="modal" onclick="if(event.target===this)hideApiKeyModal()">
        <div class="modal-content">
            <h3>API Configuration</h3>
            <label>Airforce API Key (required for video generation)</label>
            <input type="password" id="airforceKeyInput" placeholder="Enter your API key...">
            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; justify-content: flex-end;">
                <button onclick="hideApiKeyModal()" class="secondary">Cancel</button>
                <button onclick="saveApiKey()">Save</button>
            </div>
        </div>
    </div>

    <script>
        // --- State ---
        const state = {
            apiKey: localStorage.getItem('airforce_api_key') || '',
            history: JSON.parse(localStorage.getItem('video_history') || '[]'),
            referenceImages: [],
            currentVideoUrl: null,
            capturedFrame: null,
            combineQueue: [],
            ffmpeg: null,
            ffmpegLoaded: false,
            extractVideo: null
        };

        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?'
        ];

        // --- Theme ---
        function toggleTheme() {
            const html = document.documentElement;
            const isDark = html.getAttribute('data-theme') === 'dark';
            const next = isDark ? 'light' : 'dark';
            html.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
            document.getElementById('themeIcon').textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
        }

        function initTheme() {
            const saved = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', saved);
            document.getElementById('themeIcon').textContent = saved === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        // --- Navigation ---
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tab + 'Panel').classList.add('active');
            if (tab === 'history') renderHistory();
            if (tab === 'combine') updateCombineSelect();
            if (tab === 'extract') populateExtractHistory();
        }

        // --- Utilities ---
        function showStatus(id, msg, type='info') {
            const el = document.getElementById(id);
            el.textContent = msg;
            el.className = 'status active ' + type;
            if (type !== 'error') setTimeout(() => el.classList.remove('active'), 5000);
        }

        // --- AnonDrop (Exact logic from AnonDropUpload5) ---
        async function uploadToAnonDrop(file) {
            try {
                // Step 1: Get user key
                const regResponse = await fetch('https://anondrop.net/register', { method: 'GET' });
                const regText = await regResponse.text();
                const keyMatch = regText.match(/localStorage\.setItem\('userkey',\s*'(\d+)'\)/);
                
                if (!keyMatch || !keyMatch[1]) {
                    throw new Error('Could not extract user key from /register response');
                }
                
                const userKey = keyMatch[1];
                
                // Step 2: Upload
                const formData = new FormData();
                formData.append('file', file);
                
                const uploadUrl = `https://anondrop.net/upload?key=${userKey}`;
                const uploadResponse = await fetch(uploadUrl, {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Upload failed: ${uploadResponse.status} - ${errorText}`);
                }
                
                const uploadResult = await uploadResponse.text();
                const linkMatch = uploadResult.match(/href='(https:\/\/anondrop\.net\/(\d+))'/);
                
                if (!linkMatch) {
                    throw new Error('Could not extract file link from response');
                }
                
                const fileId = linkMatch[2];
                const extension = file.name.split('.').pop().toLowerCase();
                const directUrl = `https://anondrop.net/${fileId}/file.${extension}`;
                
                return directUrl;
            } catch (err) {
                throw new Error('AnonDrop Error: ' + err.message);
            }
        }

        // --- Generate (Exact logic from ImageAndVideoStudio) ---
        document.getElementById('promptInput').addEventListener('input', (e) => {
            document.getElementById('charCount').textContent = e.target.value.length;
        });

        function handleImageSelect(e) {
            const files = Array.from(e.target.files);
            if (state.referenceImages.length + files.length > 2) {
                showStatus('generateStatus', 'Maximum 2 images allowed', 'error');
                return;
            }
            files.forEach(file => {
                const url = URL.createObjectURL(file);
                state.referenceImages.push({ file, url, anondropUrl: null });
            });
            renderImagePreviews();
        }

        function renderImagePreviews() {
            const container = document.getElementById('imagePreviewContainer');
            container.innerHTML = state.referenceImages.map((img, idx) => `
                <div class="preview-item">
                    <img src="${img.url}">
                    <div class="remove" onclick="removeImage(${idx})">√ó</div>
                </div>
            `).join('');
        }

        function removeImage(idx) {
            URL.revokeObjectURL(state.referenceImages[idx].url);
            state.referenceImages.splice(idx, 1);
            renderImagePreviews();
        }

        // Drag and drop for images
        const dropZone = document.getElementById('dropZone');
        dropZone.addEventListener('dragover', (e) => { 
            e.preventDefault(); 
            dropZone.style.borderColor = 'var(--primary)'; 
            dropZone.style.background = 'rgba(99, 102, 241, 0.1)';
        });
        dropZone.addEventListener('dragleave', () => { 
            dropZone.style.borderColor = 'var(--border)'; 
            dropZone.style.background = 'var(--bg)';
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = 'var(--border)';
            dropZone.style.background = 'var(--bg)';
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (state.referenceImages.length + files.length > 2) {
                showStatus('generateStatus', 'Maximum 2 images allowed', 'error');
                return;
            }
            files.forEach(file => {
                state.referenceImages.push({ 
                    file, 
                    url: URL.createObjectURL(file), 
                    anondropUrl: null 
                });
            });
            renderImagePreviews();
        });

        async function generateVideo() {
            const prompt = document.getElementById('promptInput').value.trim();
            if (!prompt) return showStatus('generateStatus', 'Please enter a prompt', 'error');
            if (!state.apiKey) return showStatus('generateStatus', 'API key required. Click üîë', 'error');
            if (prompt.length > 500) return showStatus('generateStatus', 'Prompt exceeds 500 characters', 'error');

            const btn = document.getElementById('generateBtn');
            const spinner = document.getElementById('genSpinner');
            btn.disabled = true;
            spinner.classList.remove('hidden');

            try {
                // Upload reference images to AnonDrop (required by Grok)
                const imageUrls = [];
                for (let img of state.referenceImages) {
                    if (!img.anondropUrl) {
                        showStatus('generateStatus', 'Uploading image to AnonDrop...', 'info');
                        img.anondropUrl = await uploadToAnonDrop(img.file);
                    }
                    imageUrls.push(img.anondropUrl);
                }

                // Prepare request (exactly as in ImageAndVideoStudio)
                const aspectRatio = document.getElementById('grokAspectRatio').value;
                let size = '1024x1024';
                if (aspectRatio === '3:2') size = '1536x1024';
                if (aspectRatio === '2:3') size = '1024x1536';

                const requestBody = {
                    model: 'grok-imagine-video',
                    prompt: prompt,
                    n: 1,
                    size: size,
                    response_format: 'url',
                    sse: true,
                    mode: document.getElementById('grokMode').value,
                    aspectRatio: aspectRatio
                };

                if (imageUrls.length > 0) {
                    requestBody.image = imageUrls.length === 1 ? imageUrls[0] : imageUrls;
                }

                showStatus('generateStatus', 'Generating video... (30-60s)', 'info');

                // API call
                const response = await fetch('https://api.airforce/v1/images/generations', {
                    method: 'POST',
                    headers: {
                        'Authorization': state.apiKey,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText}`);
                }

                // Handle response (SSE or JSON)
                let finalUrl = null;
                const contentType = response.headers.get('content-type') || '';

                if (contentType.includes('application/json')) {
                    const data = await response.json();
                    // Deep search for URL
                    const findUrl = (obj) => {
                        if (!obj || typeof obj !== 'object') return null;
                        for (const [key, val] of Object.entries(obj)) {
                            if (typeof val === 'string' && val.startsWith('http')) return val;
                            const found = findUrl(val);
                            if (found) return found;
                        }
                        return null;
                    };
                    finalUrl = findUrl(data);
                } else {
                    // SSE streaming
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            const trimmed = line.trim();
                            if (!trimmed || !trimmed.startsWith('data: ')) continue;
                            const dataStr = trimmed.slice(6);
                            if (dataStr === '[DONE]' || dataStr === ': keepalive') continue;
                            
                            try {
                                const data = JSON.parse(dataStr);
                                if (data.progress !== undefined) {
                                    showStatus('generateStatus', `Generating... ${Math.round(data.progress)}%`, 'info');
                                }
                                // Search for URL
                                const findUrl = (obj) => {
                                    if (!obj || typeof obj !== 'object') return null;
                                    for (const [k, v] of Object.entries(obj)) {
                                        if (typeof v === 'string' && v.startsWith('http') && v.includes('.mp4')) return v;
                                        const found = findUrl(v);
                                        if (found) return found;
                                    }
                                    return null;
                                };
                                const found = findUrl(data);
                                if (found) finalUrl = found;
                            } catch (e) {}
                        }
                    }
                }

                if (!finalUrl) throw new Error('No video URL received from API');

                // Success
                state.currentVideoUrl = finalUrl;
                document.getElementById('resultVideo').src = finalUrl;
                document.getElementById('resultCard').style.display = 'block';
                
                // Add to history
                state.history.unshift({
                    url: finalUrl,
                    prompt: prompt,
                    timestamp: Date.now(),
                    model: 'grok-video'
                });
                localStorage.setItem('video_history', JSON.stringify(state.history.slice(0, 100)));
                
                showStatus('generateStatus', 'Video generated successfully!', 'success');
                document.getElementById('resultCard').scrollIntoView({ behavior: 'smooth' });

            } catch (error) {
                console.error(error);
                showStatus('generateStatus', 'Failed: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
                spinner.classList.add('hidden');
            }
        }

        function downloadCurrentVideo() {
            if (!state.currentVideoUrl) return;
            const a = document.createElement('a');
            a.href = state.currentVideoUrl;
            a.download = `grok-video-${Date.now()}.mp4`;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }

        function addToCombineFromCurrent() {
            if (!state.currentVideoUrl) return;
            addToQueue({ url: state.currentVideoUrl, name: `Generated ${new Date().toLocaleTimeString()}` });
            showStatus('generateStatus', 'Added to combine queue! Switch to Combine tab.', 'success');
        }

        function extractFromCurrent() {
            if (!state.currentVideoUrl) return;
            // Switch to extract tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab')[1].classList.add('active'); // Extract tab
            document.getElementById('extractPanel').classList.add('active');
            
            document.getElementById('extractSource').value = 'url';
            changeExtractSource();
            document.getElementById('extractUrlInput').value = state.currentVideoUrl;
            loadExtractVideo();
        }

        // --- Extract Frames (Exact logic from MP4GIF_andMore) ---
        function changeExtractSource() {
            const source = document.getElementById('extractSource').value;
            document.getElementById('historySelect').style.display = source === 'history' ? 'block' : 'none';
            document.getElementById('extractFileInput').style.display = source === 'file' ? 'block' : 'none';
            document.getElementById('extractUrlInput').style.display = source === 'url' ? 'block' : 'none';
            document.getElementById('extractLoadBtn').style.display = source === 'file' ? 'none' : 'inline-flex';
            if (source === 'history') populateExtractHistory();
        }

        function populateExtractHistory() {
            const sel = document.getElementById('historySelect');
            sel.innerHTML = '<option value="">Select from history...</option>' + 
                state.history.map(h => `<option value="${h.url}">${h.prompt?.substring(0,40)||'Video'}...</option>`).join('');
        }

        function handleExtractFile(e) {
            const file = e.target.files[0];
            if (file) setupExtractVideo(URL.createObjectURL(file), file.name);
        }

        async function loadExtractVideo() {
            const source = document.getElementById('extractSource').value;
            let url = '';
            
            if (source === 'history') {
                url = document.getElementById('historySelect').value;
            } else if (source === 'url') {
                url = document.getElementById('extractUrlInput').value.trim();
            }
            
            if (!url && source !== 'file') {
                alert('Please select or enter a video URL');
                return;
            }
            
            if (url) setupExtractVideo(url, 'Video');
        }

        function setupExtractVideo(url, name) {
            const video = document.getElementById('extractVideo');
            video.src = url;
            video.style.display = 'block';
            document.getElementById('extractControls').style.display = 'block';
            state.extractVideo = video;
            
            video.onloadedmetadata = () => {
                // Set canvas size proportional
                const canvas = document.getElementById('frameCanvas');
                const maxWidth = 640;
                const scale = maxWidth / video.videoWidth;
                canvas.width = maxWidth;
                canvas.height = video.videoHeight * scale;
                
                // Setup slider
                const slider = document.getElementById('videoSlider');
                slider.max = video.duration;
                slider.value = 0;
                slider.step = 0.01;
                
                drawFrame();
            };
        }

        function updateVideoFromSlider() {
            if (!state.extractVideo) return;
            state.extractVideo.currentTime = document.getElementById('videoSlider').value;
        }

        function drawFrame() {
            if (!state.extractVideo || state.extractVideo.readyState < 2) return;
            const canvas = document.getElementById('frameCanvas');
            const ctx = canvas.getContext('2d');
            ctx.drawImage(state.extractVideo, 0, 0, canvas.width, canvas.height);
            document.getElementById('timeDisplay').textContent = formatTime(state.extractVideo.currentTime);
            document.getElementById('videoSlider').value = state.extractVideo.currentTime;
        }

        // Update frame as video plays
        document.getElementById('extractVideo').addEventListener('timeupdate', drawFrame);

        function seekFrame(direction) {
            if (!state.extractVideo) return;
            state.extractVideo.currentTime += direction * (1/30);
        }

        function goToStart() {
            if (!state.extractVideo) return;
            state.extractVideo.currentTime = 0;
        }

        function goToEnd() {
            if (!state.extractVideo) return;
            state.extractVideo.currentTime = state.extractVideo.duration;
        }

        function captureFrame() {
            const canvas = document.getElementById('frameCanvas');
            canvas.toBlob(blob => {
                state.capturedFrame = blob;
                const url = URL.createObjectURL(blob);
                document.getElementById('frameUploadPreview').innerHTML = `<img src="${url}" style="max-width: 200px; border-radius: 4px; border: 2px solid var(--border);">`;
                document.getElementById('uploadFrameSection').style.display = 'block';
                document.getElementById('frameUploadResult').innerHTML = '';
            }, 'image/jpeg', 0.95);
        }

        function extractSpecificFrame(which) {
            if (!state.extractVideo) return;
            if (which === 'first') {
                state.extractVideo.currentTime = 0;
            } else {
                state.extractVideo.currentTime = state.extractVideo.duration;
            }
            // Wait for seek to complete
            setTimeout(captureFrame, 100);
        }

        async function uploadCapturedFrame() {
            if (!state.capturedFrame) return;
            
            const btn = document.getElementById('uploadFrameBtn');
            const resultDiv = document.getElementById('frameUploadResult');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Uploading...';
            
            try {
                const file = new File([state.capturedFrame], `frame-${Date.now()}.jpg`, { type: 'image/jpeg' });
                const url = await uploadToAnonDrop(file);
                
                resultDiv.innerHTML = `
                    <div style="background: var(--success); color: white; padding: 0.75rem; border-radius: var(--radius); word-break: break-all; font-size: 0.9rem;">
                        ‚úÖ Uploaded!<br>
                        <div style="margin-top: 0.5rem; background: rgba(255,255,255,0.2); padding: 0.5rem; border-radius: 4px;">${url}</div>
                    </div>
                `;
                navigator.clipboard.writeText(url);
                showStatus('generateStatus', 'Frame URL copied to clipboard!', 'success');
            } catch (err) {
                resultDiv.innerHTML = `<div style="background: var(--error); color: white; padding: 0.75rem; border-radius: var(--radius);">${err.message}</div>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = '‚òÅÔ∏è Get Link';
            }
        }

        // --- Combine Videos (Exact logic from VideoCombine) ---
        function updateCombineSelect() {
            const sel = document.getElementById('addFromHistory');
            sel.innerHTML = '<option value="">Add from history...</option>' +
                state.history.map(h => `<option value="${h.url}">${h.prompt?.substring(0,40)||'Video'}...</option>`).join('');
        }

        function addSelectedToQueue() {
            const url = document.getElementById('addFromHistory').value;
            if (!url) return;
            const item = state.history.find(h => h.url === url);
            addToQueue({ url, name: item?.prompt?.substring(0,50) || 'Video' });
        }

        function addToQueue(video) {
            state.combineQueue.push({ ...video, id: Date.now() + Math.random() });
            renderQueue();
        }

        function renderQueue() {
            const container = document.getElementById('videoQueue');
            const btn = document.getElementById('combineBtn');
            
            if (!state.combineQueue.length) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No videos in queue</div>';
                btn.disabled = true;
                return;
            }
            
            btn.disabled = state.combineQueue.length < 2 || !state.ffmpegLoaded;
            
            container.innerHTML = '';
            state.combineQueue.forEach((video, index) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                div.draggable = true;
                div.innerHTML = `
                    <span style="cursor: grab; color: var(--text-muted); font-size: 1.2rem; user-select: none;">‚ãÆ‚ãÆ</span>
                    <img src="${video.url}#t=0.001" class="queue-thumb" onerror="this.style.display='none'" alt="">
                    <div class="queue-info">
                        <div class="queue-title">${video.name}</div>
                        <div class="queue-meta">Position ${index + 1} ‚Ä¢ Drag to reorder</div>
                    </div>
                    <button onclick="removeFromQueue(${index})" class="icon-btn" style="background: var(--error); width: 32px; height: 32px;">√ó</button>
                `;
                
                // Drag and drop handlers
                div.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    div.style.opacity = '0.5';
                });
                
                div.addEventListener('dragend', () => {
                    div.style.opacity = '1';
                });
                
                div.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });
                
                div.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIdx = index;
                    if (fromIdx !== toIdx) {
                        const [moved] = state.combineQueue.splice(fromIdx, 1);
                        state.combineQueue.splice(toIdx, 0, moved);
                        renderQueue();
                    }
                });
                
                container.appendChild(div);
            });
        }

        function removeFromQueue(idx) {
            state.combineQueue.splice(idx, 1);
            renderQueue();
        }

        function clearQueue() {
            state.combineQueue = [];
            renderQueue();
            document.getElementById('combineResult').style.display = 'none';
        }

        // FFmpeg initialization (same as VideoCombine.html)
        async function initFFmpeg() {
            if (state.ffmpegLoaded || state.ffmpegLoading) return;
            state.ffmpegLoading = true;
            
            try {
                // Use globals from the scripts (FFmpegWASM, FFmpegUtil)
                const { FFmpeg } = FFmpegWASM;
                const { fetchFile } = FFmpegUtil;
                
                const ffmpeg = new FFmpeg();
                
                ffmpeg.on('log', ({ message }) => {
                    console.log('FFmpeg:', message);
                });
                
                ffmpeg.on('progress', ({ progress, time }) => {
                    const percent = Math.round(progress * 100);
                    document.getElementById('combineProgressFill').style.width = percent + '%';
                    document.getElementById('combineProgressFill').textContent = percent + '%';
                    document.getElementById('combineStatusText').textContent = `Processing... ${percent}%`;
                });
                
                // Same URLs as VideoCombine.html
                await ffmpeg.load({
                    coreURL: 'https://martinlh77.github.io/AI-apps/tools/ffmpeg/ffmpeg-core.js',
                    wasmURL: 'https://martinlh77.github.io/AI-apps/tools/ffmpeg/ffmpeg-core.wasm'
                });
                
                state.ffmpeg = ffmpeg;
                state.fetchFile = fetchFile;
                state.ffmpegLoaded = true;
                
                if (state.combineQueue.length >= 2) {
                    document.getElementById('combineBtn').disabled = false;
                }
            } catch (err) {
                console.error('FFmpeg init failed:', err);
                alert('Failed to load FFmpeg. Ensure files are in tools/ffmpeg/ directory.');
            } finally {
                state.ffmpegLoading = false;
            }
        }

        // Fetch video with CORS proxy fallback (from VideoCombine.html)
        async function fetchVideoWithCors(url) {
            try {
                const response = await fetch(url);
                if (response.ok) return await response.blob();
            } catch (e) {
                // Try CORS proxies
                for (const proxy of CORS_PROXIES) {
                    try {
                        const response = await fetch(proxy + encodeURIComponent(url));
                        if (response.ok) return await response.blob();
                    } catch (err) { continue; }
                }
            }
            throw new Error('Unable to fetch video. CORS blocked and proxies failed.');
        }

        async function combineVideos() {
            if (!state.ffmpegLoaded) await initFFmpeg();
            if (state.combineQueue.length < 2) return;
            
            const btn = document.getElementById('combineBtn');
            const progressContainer = document.getElementById('combineProgress');
            const statusText = document.getElementById('combineStatusText');
            
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Processing...';
            progressContainer.style.display = 'block';
            
            try {
                const { ffmpeg, fetchFile } = state;
                const inputFiles = [];
                
                // Download videos (with CORS handling)
                for (let i = 0; i < state.combineQueue.length; i++) {
                    const video = state.combineQueue[i];
                    statusText.textContent = `Loading video ${i + 1} of ${state.combineQueue.length}...`;
                    
                    const blob = await fetchVideoWithCors(video.url);
                    const fileName = `input${i}.mp4`;
                    await ffmpeg.writeFile(fileName, await fetchFile(blob));
                    inputFiles.push(fileName);
                }
                
                // Create concat list
                statusText.textContent = 'Preparing combination...';
                const concatList = inputFiles.map(f => `file '${f}'`).join('\n');
                await ffmpeg.writeFile('concat_list.txt', concatList);
                
                // Build FFmpeg command
                const resolution = document.getElementById('combineResolution').value;
                const audioMode = document.getElementById('combineAudio').value;
                
                const args = ['-f', 'concat', '-safe', '0', '-i', 'concat_list.txt'];
                
                if (resolution !== 'original') {
                    const targetHeight = parseInt(resolution);
                    const targetWidth = Math.round(targetHeight * 16/9);
                    args.push('-vf', `scale=${targetWidth}:${targetHeight}:force_original_aspect_ratio=decrease,pad=${targetWidth}:${targetHeight}:(ow-iw)/2:(oh-ih)/2:black,setsar=1`);
                }
                
                args.push('-c:v', 'libx264', '-preset', 'fast', '-crf', '23', '-pix_fmt', 'yuv420p', '-movflags', '+faststart');
                
                if (audioMode === 'mute') {
                    args.push('-an');
                } else {
                    args.push('-c:a', 'aac', '-b:a', '128k');
                }
                
                args.push('-y', 'output.mp4');
                
                statusText.textContent = 'Combining and encoding...';
                await ffmpeg.exec(args);
                
                // Read result
                statusText.textContent = 'Finalizing...';
                const data = await ffmpeg.readFile('output.mp4');
                const blob = new Blob([data.buffer], { type: 'video/mp4' });
                const url = URL.createObjectURL(blob);
                
                // Display
                document.getElementById('combinedVideo').src = url;
                document.getElementById('combinedDownload').href = url;
                document.getElementById('combinedDownload').download = `combined-${Date.now()}.mp4`;
                document.getElementById('combineResult').style.display = 'block';
                
                // Cleanup
                for (const file of inputFiles) {
                    await ffmpeg.deleteFile(file);
                }
                await ffmpeg.deleteFile('concat_list.txt');
                await ffmpeg.deleteFile('output.mp4');
                
                statusText.textContent = 'Complete!';
                
            } catch (err) {
                console.error(err);
                alert('Error combining videos: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üé¨ Combine Videos';
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    document.getElementById('combineProgressFill').style.width = '0%';
                }, 3000);
            }
        }

        // --- History Management ---
        function renderHistory() {
            const grid = document.getElementById('historyGrid');
            if (!state.history.length) {
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-muted); padding: 2rem;">No history yet. Generate some videos!</div>';
                return;
            }
            
            grid.innerHTML = state.history.map((item, idx) => `
                <div class="history-item" onclick="window.open('${item.url}', '_blank')">
                    <video src="${item.url}" muted loop preload="metadata" onmouseenter="this.play()" onmouseleave="this.pause()"></video>
                    <div class="history-meta">${new Date(item.timestamp).toLocaleDateString()}</div>
                    <div class="history-actions" onclick="event.stopPropagation()">
                        <button class="icon-btn" onclick="copyUrl('${item.url}')" title="Copy URL">üìã</button>
                        <button class="icon-btn" onclick="addToQueueFromHistory(${idx})" title="Add to Combine">‚ûï</button>
                        <button class="icon-btn" onclick="deleteHistoryItem(${idx})" title="Delete" style="background: var(--error);">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function copyUrl(url) {
            navigator.clipboard.writeText(url);
            showStatus('generateStatus', 'URL copied!', 'success');
        }

        function addToQueueFromHistory(idx) {
            const item = state.history[idx];
            addToQueue({ url: item.url, name: item.prompt?.substring(0,50) || 'Video' });
            showStatus('generateStatus', 'Added to combine queue', 'success');
        }

        function deleteHistoryItem(idx) {
            if (!confirm('Delete this item from history?')) return;
            state.history.splice(idx, 1);
            localStorage.setItem('video_history', JSON.stringify(state.history));
            renderHistory();
        }

        function clearHistory() {
            if (!confirm('Clear all history? This cannot be undone.')) return;
            state.history = [];
            localStorage.setItem('video_history', '[]');
            renderHistory();
        }

        function exportHistory() {
            const data = {
                version: 1,
                exported: Date.now(),
                history: state.history
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `video-workflow-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            showStatus('generateStatus', 'History exported', 'success');
        }

        function importHistory(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (!data.history || !Array.isArray(data.history)) {
                        throw new Error('Invalid backup file format');
                    }
                    
                    if (!confirm(`Import ${data.history.length} items? This will merge with existing history.`)) {
                        return;
                    }
                    
                    // Merge and deduplicate by URL
                    const combined = [...data.history, ...state.history];
                    state.history = combined.filter((item, index, self) => 
                        index === self.findIndex(t => t.url === item.url)
                    );
                    
                    localStorage.setItem('video_history', JSON.stringify(state.history.slice(0, 100)));
                    renderHistory();
                    showStatus('generateStatus', `Imported successfully! Total: ${state.history.length} items`, 'success');
                } catch (err) {
                    alert('Failed to import: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        // --- API Key ---
        function showApiKeyModal() {
            document.getElementById('airforceKeyInput').value = state.apiKey;
            document.getElementById('apiKeyModal').classList.add('active');
        }

        function hideApiKeyModal() {
            document.getElementById('apiKeyModal').classList.remove('active');
        }

        function saveApiKey() {
            const key = document.getElementById('airforceKeyInput').value.trim();
            state.apiKey = key;
            localStorage.setItem('airforce_api_key', key);
            hideApiKeyModal();
            showStatus('generateStatus', 'API key saved', 'success');
        }

        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            changeExtractSource();
            // Pre-init FFmpeg
            setTimeout(() => initFFmpeg(), 1000);
        });
    </script>
</body>
</html>
