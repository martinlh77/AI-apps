<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Farkle: The Working Version</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #0f0; user-select: none; }
        #ui { position: absolute; top: 10px; left: 10px; width: 260px; pointer-events: none; z-index: 10; }
        .panel { background: rgba(0, 0, 0, 0.95); padding: 15px; border: 2px solid #0f0; pointer-events: auto; font-size: 13px; }
        h2 { margin: 0 0 10px 0; font-size: 14px; color: #0f0; text-align: center; }
        .stat { display: flex; justify-content: space-between; margin: 4px 0; }
        .val { color: #ff0; font-weight: bold; }
        #msg { position: absolute; top: 25%; width: 100%; text-align: center; font-size: 60px; font-weight: 900; color: #f00; pointer-events: none; text-shadow: 0 0 20px #000; z-index: 100; }
        .controls { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; gap: 15px; pointer-events: none; }
        button { pointer-events: auto; width: 130px; padding: 15px; border: 2px solid #0f0; background: #000; color: #0f0; font-weight: bold; font-size: 14px; cursor: pointer; font-family: inherit; }
        button:disabled { border-color: #030; color: #030; cursor: not-allowed; }
        #status { position: absolute; bottom: 100px; width: 100%; text-align: center; color: #0f0; font-weight: bold; font-size: 12px; }
        #settings { position: absolute; top: 10px; right: 10px; width: 260px; pointer-events: none; z-index: 10; }
        .settings-panel { background: rgba(0, 0, 0, 0.95); padding: 15px; border: 2px solid #0f0; pointer-events: auto; font-size: 12px; }
        .setting-group { margin: 10px 0; }
        .setting-group label { display: block; margin-bottom: 5px; color: #0f0; font-weight: bold; }
        .setting-group select { width: 100%; padding: 5px; background: #000; color: #0f0; border: 1px solid #0f0; font-family: inherit; cursor: pointer; }
    </style>
</head>
<body>

<div id="msg"></div>
<div id="ui">
    <div class="panel">
        <h2>[ FARKLE_SYS v4.0 ]</h2>
        <div class="stat"><span>HUMAN:</span> <span id="p-score" class="val">0</span></div>
        <div class="stat"><span>CPU:</span> <span id="ai-score" class="val">0</span></div>
        <div class="stat"><span>TURN:</span> <span id="current-player" class="val">Human</span></div>
        <hr style="border:0; border-top:1px solid #0f0; margin:8px 0;">
        <div class="stat"><span>BANKED:</span> <span id="turn-total" class="val">0</span></div>
        <div class="stat"><span>SELECTED:</span> <span id="selection-score" class="val">0</span></div>
    </div>
</div>

<div id="settings">
    <div class="settings-panel">
        <h2>[ SETTINGS ]</h2>
        <div class="setting-group">
            <label>DICE STYLE:</label>
            <select id="dice-style" onchange="changeDiceStyle()">
                <option value="clear">Clear Plastic</option>
                <option value="solid">Solid</option>
                <option value="matte">Matte</option>
                <option value="wooden">Wooden</option>
                <option value="marble" selected>Marble</option>
            </select>
        </div>
        <div class="setting-group">
            <label>TABLE SURFACE:</label>
            <select id="table-surface" onchange="changeTableSurface()">
                <option value="red-felt">Red Felt</option>
                <option value="blue-felt">Blue Felt</option>
                <option value="green-felt" selected>Green Felt</option>
                <option value="wood">Wood</option>
                <option value="steel">Steel</option>
                <option value="dirt" selected>Dirt</option>
            </select>
        </div>
    </div>
</div>

<div id="status">READY</div>

<div class="controls">
    <button id="roll-btn" onclick="userRoll()">ROLL</button>
    <button id="bank-btn" onclick="userBank()" disabled>BANK</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    let scene, camera, renderer, controls, dice = [], tableMesh;
    const state = {
        scores: { Player: 0, AI: 0 },
        turnScore: 0,
        currentPlayer: 'Player',
        isRolling: false,
        farkled: false,
        firstRollOfTurn: true,
        diceStyle: 'clear',
        tableSurface: 'green-felt'
    };

    // Sound effects using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        const now = audioContext.currentTime;
        
        switch(type) {
            case 'roll':
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                oscillator.start(now);
                oscillator.stop(now + 0.3);
                break;
            case 'select':
                oscillator.frequency.setValueAtTime(400, now);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                oscillator.start(now);
                oscillator.stop(now + 0.1);
                break;
            case 'bank':
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.setValueAtTime(800, now + 0.1);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                oscillator.start(now);
                oscillator.stop(now + 0.2);
                break;
            case 'hotdice':
                for(let i = 0; i < 3; i++) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.frequency.setValueAtTime(800 + i * 200, now + i * 0.1);
                    gain.gain.setValueAtTime(0.2, now + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.15);
                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.15);
                }
                break;
            case 'farkle':
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                gainNode.gain.setValueAtTime(0.4, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                oscillator.start(now);
                oscillator.stop(now + 0.5);
                break;
        }
    }

    const slots = [
        {x: -2.5, z: -1.5}, {x: 0, z: -1.5}, {x: 2.5, z: -1.5},
        {x: -2.5, z: 1.5},  {x: 0, z: 1.5},  {x: 2.5, z: 1.5}
    ];

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 14, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 15, 10);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        createTable();
        createDice();
        window.addEventListener('resize', onResize);
        window.addEventListener('pointerdown', onClick);
        updateUI();
        animate();
    }

    function createTable() {
        const geometry = new THREE.PlaneGeometry(20, 20);
        geometry.rotateX(-Math.PI / 2);
        const material = getTableMaterial(state.tableSurface);
        tableMesh = new THREE.Mesh(geometry, material);
        tableMesh.receiveShadow = true;
        scene.add(tableMesh);
    }

    function getTableMaterial(surface) {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        switch(surface) {
            case 'red-felt':
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(0, 0, 512, 512);
                addFeltTexture(ctx);
                break;
            case 'blue-felt':
                ctx.fillStyle = '#00008B';
                ctx.fillRect(0, 0, 512, 512);
                addFeltTexture(ctx);
                break;
            case 'green-felt':
                ctx.fillStyle = '#0B6623';
                ctx.fillRect(0, 0, 512, 512);
                addFeltTexture(ctx);
                break;
            case 'wood':
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, 0, 512, 512);
                addWoodTexture(ctx);
                break;
            case 'steel':
                ctx.fillStyle = '#708090';
                ctx.fillRect(0, 0, 512, 512);
                addMetalTexture(ctx);
                break;
            case 'dirt':
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 512, 512);
                addDirtTexture(ctx);
                break;
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(4, 4);
        return new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
    }

    function addFeltTexture(ctx) {
        ctx.globalAlpha = 0.1;
        for(let i = 0; i < 5000; i++) {
            ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#000000';
            ctx.fillRect(Math.random() * 512, Math.random() * 512, 1, 1);
        }
        ctx.globalAlpha = 1;
    }

    function addWoodTexture(ctx) {
        for(let i = 0; i < 20; i++) {
            ctx.strokeStyle = `rgba(101, 67, 33, ${Math.random() * 0.3})`;
            ctx.lineWidth = Math.random() * 3 + 1;
            ctx.beginPath();
            ctx.moveTo(0, Math.random() * 512);
            ctx.lineTo(512, Math.random() * 512);
            ctx.stroke();
        }
    }

    function addMetalTexture(ctx) {
        const gradient = ctx.createLinearGradient(0, 0, 512, 512);
        gradient.addColorStop(0, '#A9A9A9');
        gradient.addColorStop(0.5, '#708090');
        gradient.addColorStop(1, '#556B2F');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);
    }

    function addDirtTexture(ctx) {
        for(let i = 0; i < 3000; i++) {
            const shade = Math.random() * 50 + 51;
            ctx.fillStyle = `rgb(${shade}, ${shade - 20}, ${shade - 40})`;
            ctx.fillRect(Math.random() * 512, Math.random() * 512, Math.random() * 3, Math.random() * 3);
        }
    }

    function changeTableSurface() {
        state.tableSurface = document.getElementById('table-surface').value;
        tableMesh.material = getTableMaterial(state.tableSurface);
    }

    function changeDiceStyle() {
        state.diceStyle = document.getElementById('dice-style').value;
        dice.forEach(die => {
            const val = die.userData.val;
            setDieValue(die, val);
        });
    }

    function createDieMaterial(value, style) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        const colors = {1:'#e74c3c', 2:'#3498db', 3:'#2ecc71', 4:'#f39c12', 5:'#9b59b6', 6:'#1abc9c'};
        const baseColor = colors[value] || '#fff';
        
        switch(style) {
            case 'clear':
                ctx.fillStyle = baseColor;
                ctx.globalAlpha = 0.6;
                ctx.fillRect(0, 0, 128, 128);
                ctx.globalAlpha = 1;
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 4;
                ctx.strokeRect(2, 2, 124, 124);
                break;
            case 'solid':
                ctx.fillStyle = baseColor;
                ctx.fillRect(0, 0, 128, 128);
                break;
            case 'matte':
                ctx.fillStyle = baseColor;
                ctx.fillRect(0, 0, 128, 128);
                // Add matte texture
                ctx.globalAlpha = 0.2;
                for(let i = 0; i < 500; i++) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(Math.random() * 128, Math.random() * 128, 1, 1);
                }
                ctx.globalAlpha = 1;
                break;
            case 'wooden':
                ctx.fillStyle = '#D2691E';
                ctx.fillRect(0, 0, 128, 128);
                // Add wood grain
                for(let i = 0; i < 10; i++) {
                    ctx.strokeStyle = `rgba(101, 67, 33, ${Math.random() * 0.3})`;
                    ctx.lineWidth = Math.random() * 2 + 1;
                    ctx.beginPath();
                    ctx.moveTo(0, Math.random() * 128);
                    ctx.lineTo(128, Math.random() * 128);
                    ctx.stroke();
                }
                break;
            case 'marble':
                // Marble base
                const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 90);
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(1, shadeColor(baseColor, -40));
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 128, 128);
                // Marble veins
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                for(let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * 128, Math.random() * 128);
                    ctx.quadraticCurveTo(Math.random() * 128, Math.random() * 128, Math.random() * 128, Math.random() * 128);
                    ctx.stroke();
                }
                break;
        }
        
        // Draw number
        ctx.fillStyle = style === 'wooden' ? '#000000' : (style === 'clear' ? baseColor : '#ffffff');
        ctx.font = 'bold 80px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(value, 64, 64);
        
        const texture = new THREE.CanvasTexture(canvas);
        
        let materialProps = { map: texture };
        switch(style) {
            case 'clear':
                materialProps.transparent = true;
                materialProps.opacity = 0.7;
                materialProps.metalness = 0.1;
                materialProps.roughness = 0.2;
                break;
            case 'solid':
                materialProps.metalness = 0.2;
                materialProps.roughness = 0.5;
                break;
            case 'matte':
                materialProps.metalness = 0;
                materialProps.roughness = 1;
                break;
            case 'wooden':
                materialProps.metalness = 0;
                materialProps.roughness = 0.9;
                break;
            case 'marble':
                materialProps.metalness = 0.3;
                materialProps.roughness = 0.3;
                break;
        }
        
        return new THREE.MeshStandardMaterial(materialProps);
    }

    function shadeColor(color, percent) {
        const num = parseInt(color.replace("#",""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
            (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
            .toString(16).slice(1);
    }

    function createDice() {
        const geo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
        for(let i=0; i<6; i++) {
            const mat = createDieMaterial(1, state.diceStyle);
            const die = new THREE.Mesh(geo, [mat, mat, mat, mat, mat, mat]);
            die.castShadow = true;
            die.userData = { id: i, val: 1, active: true, selected: false };
            scene.add(die);
            dice.push(die);
        }
        resetDice();
    }

    function setDieValue(die, value) {
        die.userData.val = value;
        const mat = createDieMaterial(value, state.diceStyle);
        die.material = [mat, mat, mat, mat, mat, mat];
    }

    function resetDice() {
        dice.forEach((d, i) => {
            d.userData.active = true;
            d.userData.selected = false;
            d.visible = true;
            d.position.set(slots[i].x, 0.45, slots[i].z);
            d.rotation.set(0, 0, 0);
            setDieValue(d, 1);
        });
        state.farkled = false;
        state.firstRollOfTurn = true;
    }

    function getScore(dieMeshes) {
        if (dieMeshes.length === 0) return { points: 0, used: 0 };
        const vals = dieMeshes.map(d => d.userData.val).sort();
        const counts = [0,0,0,0,0,0,0];
        vals.forEach(v => counts[v]++);

        let p = 0, u = 0;

        if (counts.slice(1).every(c => c === 1)) return { points: 1500, used: 6 };
        
        let pairs = 0;
        for(let i=1; i<=6; i++) if(counts[i] === 2) pairs++;
        if(pairs === 3) return { points: 1500, used: 6 };

        for(let i=1; i<=6; i++) {
            let c = counts[i];
            if (c >= 3) {
                let base = (i === 1) ? 1000 : i * 100;
                p += base * Math.pow(2, c - 3);
                u += c;
            } else {
                if (i === 1) { p += c * 100; u += c; }
                if (i === 5) { p += c * 50; u += c; }
            }
        }
        return { points: p, used: u };
    }

    async function rollPhysics(activeDice) {
        state.isRolling = true;
        updateUI("ROLLING...");
        playSound('roll');
        
        activeDice.forEach(die => {
            const val = Math.floor(Math.random() * 6) + 1;
            setDieValue(die, val);
        });
        
        const promises = activeDice.map((die, i) => {
            return new Promise(resolve => {
                const start = die.position.clone();
                const slot = slots[die.userData.id]; 
                const end = new THREE.Vector3(slot.x + (Math.random()-0.5)*0.4, 0.45, slot.z + (Math.random()-0.5)*0.4);
                const startT = performance.now();
                
                function step(now) {
                    const t = Math.min((now - startT) / 1000, 1);
                    die.position.lerpVectors(start, end, t);
                    die.position.y = 0.45 + Math.sin(t * Math.PI) * 4;
                    die.rotation.x += 0.4; 
                    die.rotation.y += 0.4;
                    
                    if (t < 1) requestAnimationFrame(step);
                    else {
                        die.position.copy(end);
                        die.position.y = 0.45;
                        resolve();
                    }
                }
                requestAnimationFrame(step);
            });
        });

        await Promise.all(promises);
        state.isRolling = false;

        const check = getScore(activeDice);
        if (check.points === 0) {
            state.farkled = true;
            state.turnScore = 0;
            playSound('farkle');
            showMsg("FARKLE!");
            setTimeout(endTurn, 2000);
        } else {
            updateUI("SELECT DICE");
        }
    }

    function onClick(e) {
        if (state.isRolling || state.currentPlayer === 'AI' || state.farkled) return;
        const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
        const ray = new THREE.Raycaster();
        ray.setFromCamera(mouse, camera);
        const hits = ray.intersectObjects(dice);
        if (hits.length > 0) {
            const d = hits[0].object;
            if (!d.userData.active) return;
            d.userData.selected = !d.userData.selected;
            d.position.y = d.userData.selected ? 1.5 : 0.45;
            playSound('select');
            updateUI();
        }
    }

    function userRoll() {
        const selected = dice.filter(d => d.userData.selected);
        if (!state.firstRollOfTurn) {
            const res = getScore(selected);
            if (selected.length === 0 || res.used !== selected.length) {
                updateUI("INVALID - FIX SELECTION");
                return;
            }
            state.turnScore += res.points;
            selected.forEach(d => { d.userData.active = false; d.visible = false; d.userData.selected = false; });
        }

        state.firstRollOfTurn = false;
        let active = dice.filter(d => d.userData.active);
        if (active.length === 0) {
            playSound('hotdice');
            showMsg("HOT DICE!");
            dice.forEach(d => { d.userData.active = true; d.visible = true; d.userData.selected = false; d.position.y = 0.45; });
            active = dice;
        }
        rollPhysics(active);
    }

    function userBank() {
        const selected = dice.filter(d => d.userData.selected);
        const res = getScore(selected);
        if (selected.length > 0 && res.used !== selected.length) return;
        state.scores[state.currentPlayer] += state.turnScore + res.points;
        playSound('bank');
        endTurn();
    }

    function endTurn() {
        state.turnScore = 0;
        state.currentPlayer = state.currentPlayer === 'Player' ? 'AI' : 'Player';
        resetDice();
        updateUI("NEW TURN");
        if (state.currentPlayer === 'AI') setTimeout(aiLogic, 1000);
    }

    async function aiLogic() {
        while (state.currentPlayer === 'AI') {
            await new Promise(r => setTimeout(r, 1000));
            const active = dice.filter(d => d.userData.active);
            await rollPhysics(active);
            if (state.farkled) break;

            await new Promise(r => setTimeout(r, 1500));
            const rolled = dice.filter(d => d.userData.active);
            const vals = rolled.map(d => d.userData.val);
            const counts = [0,0,0,0,0,0,0];
            vals.forEach(v => counts[v]++);
            
            const toPick = rolled.filter(d => (d.userData.val === 1 || d.userData.val === 5 || counts[d.userData.val] >= 3));
            const res = getScore(toPick);
            toPick.forEach(d => { d.userData.selected = true; d.position.y = 1.5; });
            playSound('select');
            updateUI("AI SELECTING...");
            
            await new Promise(r => setTimeout(r, 1500));
            if (state.turnScore + res.points >= 400 || (rolled.length - toPick.length) < 3) {
                userBank(); break;
            } else {
                state.turnScore += res.points;
                state.firstRollOfTurn = false;
                toPick.forEach(d => { d.userData.active = false; d.visible = false; d.userData.selected = false; });
                if (dice.filter(d => d.userData.active).length === 0) {
                    playSound('hotdice');
                    dice.forEach(d => { d.userData.active = true; d.visible = true; d.userData.selected = false; d.position.y = 0.45; });
                }
            }
        }
    }

    function updateUI(txt) {
        document.getElementById('p-score').innerText = state.scores.Player;
        document.getElementById('ai-score').innerText = state.scores.AI;
        document.getElementById('turn-total').innerText = state.turnScore;
        document.getElementById('current-player').innerText = state.currentPlayer === 'Player' ? 'Human' : 'AI';
        
        const selected = dice.filter(d => d.userData.selected);
        const res = getScore(selected);
        document.getElementById('selection-score').innerText = res.points;
        
        if (txt) document.getElementById('status').innerText = txt;

        const isHuman = state.currentPlayer === 'Player' && !state.isRolling && !state.farkled;
        document.getElementById('roll-btn').disabled = !isHuman;
        
        const total = state.turnScore + res.points;
        const valid = (selected.length === 0 && state.turnScore > 0) || (res.used === selected.length && res.points > 0);
        document.getElementById('bank-btn').disabled = !isHuman || total === 0 || !valid;
    }

    function showMsg(t) {
        document.getElementById('msg').innerText = t;
        setTimeout(() => document.getElementById('msg').innerText = "", 2000);
    }
    function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    init();
</script>
</body>
</html>
