<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper Plus</title>
    <style>
        :root {
            --bg: #2c3e50;
            --panel: #34495e;
            --cell: #95a5a6;
            --revealed: #ecf0f1;
            --text: #ffffff;
            --accent: #27ae60;
            --mine: #e74c3c;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        .menu, .game-container {
            background: var(--panel);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 95vw;
        }
        .grid-wrapper { display: flex; flex-direction: column; align-items: center; gap: 20px; margin: 20px 0; }
        .grid { display: grid; gap: 2px; background: #7f8c8d; border: 4px solid #7f8c8d; }
        .cell {
            width: 30px; height: 30px; background: var(--cell);
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 16px; cursor: pointer; user-select: none;
            border-radius: 2px;
        }
        .cell.revealed { background: var(--revealed); color: #2c3e50; }
        .cell.mine { background: var(--mine) !important; color: white; }
        .cell.flag { background: #f1c40f; color: #000; }
        .cell.question { background: #3498db; color: #fff; }
        .cell.hint { background: #ff7979 !important; border: 2px solid white; }
        
        .controls, .stats { margin-top: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        button {
            background: var(--accent); color: white; border: none;
            padding: 10px 18px; cursor: pointer; border-radius: 5px; font-weight: 600;
            transition: transform 0.1s;
        }
        button:hover { transform: translateY(-2px); filter: brightness(1.1); }
        button:disabled { background: #7f8c8d; cursor: not-allowed; transform: none; }
        input[type="number"] { width: 60px; padding: 5px; border-radius: 4px; border: none; }
        .hidden { display: none; }
        #remark-display { font-style: italic; color: #bdc3c7; margin-bottom: 15px; min-height: 1.2em; }
    </style>
</head>
<body>

<div id="menu" class="menu">
    <h1>Minesweeper Plus</h1>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: left; margin-bottom: 20px;">
        <label>Width: <input type="number" id="cfg-w" value="10"></label>
        <label>Height: <input type="number" id="cfg-h" value="10"></label>
        <label>Mines: <input type="number" id="cfg-m" value="15"></label>
        <label>Timed: <input type="checkbox" id="cfg-timed" checked></label>
        <label>Safe First Click: <input type="checkbox" id="cfg-guaranteed" checked></label>
    </div>
    <button onclick="startGame('single')">Solo Mode</button>
    <button onclick="startGame('pvp')">PvP vs AI</button>
</div>

<div id="game-container" class="game-container hidden">
    <div id="remark-display">Analyzing the field...</div>
    <div class="stats">
        <span>Score: <span id="stat-score">0</span></span>
        <span>Time: <span id="stat-time">--</span></span>
    </div>

    <div class="grid-wrapper">
        <div id="player-area">
            <div id="player-grid" class="grid"></div>
        </div>
        <div id="ai-area" class="hidden">
            <div style="font-size: 12px; margin-bottom: 5px; color: #e67e22;">AI PERFORMANCE MONITOR</div>
            <div id="ai-grid" class="grid"></div>
        </div>
    </div>

    <div class="controls">
        <button id="btn-hint" onclick="useHint()">Request Hint (-500)</button>
        <button id="btn-solve" onclick="runSolver()">Watch AI Solve</button>
        <button onclick="location.reload()">New Game</button>
    </div>
</div>

<script>
    const remarks = {
        start: ["A fresh start. Try not to overthink it.", "The mines are ready. Are you?", "Let's see if logic prevails today."],
        win: ["You actually cleared it. I'll update the records.", "Success! A perfectly calculated victory.", "You survived. The mines are disappointed, but I'm impressed."],
        lose: ["That was... unexpected. Let's call it a stress test.", "The math was right, but the click was wrong.", "A minor setback in an otherwise lovely day."],
        timer: ["The clock is ticking. Efficiency is key.", "Time is a finite resource. Use it wisely.", "The suspense is building. Or is that just the timer?"],
        ai: ["Watch a master at work.", "The computer doesn't guess. It knows.", "Stand back while the silicon handles this."]
    };

    let mode = 'single';
    let boards = { player: null, ai: null };
    let score = 0;
    let timer = null;
    let timeLeft = 0;
    let isPlayerTurn = true;
    let gameActive = false;

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSfx(freq, type, dur) {
        try {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + dur);
        } catch(e) {}
    }

    function setRemark(type) {
        const list = remarks[type];
        document.getElementById('remark-display').innerText = list[Math.floor(Math.random() * list.length)];
    }

    class Minesweeper {
        constructor(containerId, w, h, m, isAI) {
            this.container = document.getElementById(containerId);
            this.w = w; this.h = h; this.m = m; this.isAI = isAI;
            this.grid = []; this.revealedCount = 0;
            this.firstClick = true; this.dead = false;
            this.init();
        }

        init() {
            this.container.style.gridTemplateColumns = `repeat(${this.w}, 30px)`;
            this.container.innerHTML = '';
            for (let y = 0; y < this.h; y++) {
                this.grid[y] = [];
                for (let x = 0; x < this.w; x++) {
                    const el = document.createElement('div');
                    el.className = 'cell';
                    if (!this.isAI) {
                        el.onclick = () => handleMove(x, y);
                        el.oncontextmenu = (e) => { e.preventDefault(); this.cycleFlag(x, y); };
                    }
                    this.container.appendChild(el);
                    this.grid[y][x] = { mine: false, adj: 0, state: 0, revealed: false, el: el };
                }
            }
        }

        generate(exX, exY) {
            let placed = 0;
            const safeFirst = document.getElementById('cfg-guaranteed').checked;
            while (placed < this.m) {
                let rx = Math.floor(Math.random() * this.w), ry = Math.floor(Math.random() * this.h);
                let isSafe = safeFirst ? (Math.abs(rx - exX) <= 1 && Math.abs(ry - exY) <= 1) : (rx === exX && ry === exY);
                if (!this.grid[ry][rx].mine && !isSafe) {
                    this.grid[ry][rx].mine = true; placed++;
                }
            }
            for (let y = 0; y < this.h; y++) {
                for (let x = 0; x < this.w; x++) {
                    if (!this.grid[y][x].mine) {
                        let count = 0;
                        this.getNeighbors(x, y).forEach(n => { if(this.grid[n.y][n.x].mine) count++; });
                        this.grid[y][x].adj = count;
                    }
                }
            }
        }

        getNeighbors(x, y) {
            let n = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    let nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < this.w && ny >= 0 && ny < this.h && !(dx === 0 && dy === 0)) n.push({x: nx, y: ny});
                }
            }
            return n;
        }

        reveal(x, y) {
            let cell = this.grid[y][x];
            if (cell.revealed || cell.state === 1) return;
            cell.revealed = true;
            cell.el.classList.add('revealed');
            this.revealedCount++;

            if (cell.mine) {
                cell.el.classList.add('mine');
                cell.el.innerText = 'ðŸ’£';
                this.dead = true;
                playSfx(120, 'sawtooth', 0.5);
                return;
            }

            playSfx(300 + (cell.adj * 60), 'sine', 0.05);
            cell.el.innerText = cell.adj || '';
            const colors = ['', 'blue', 'green', 'red', 'darkblue', 'brown', 'cyan', 'black', 'gray'];
            if(cell.adj > 0) cell.el.style.color = colors[cell.adj];

            if (cell.adj === 0) {
                this.getNeighbors(x, y).forEach(n => this.reveal(n.x, n.y));
            }
        }

        cycleFlag(x, y) {
            if (this.grid[y][x].revealed || !gameActive) return;
            let cell = this.grid[y][x];
            cell.state = (cell.state + 1) % 3;
            cell.el.className = 'cell' + (cell.state === 1 ? ' flag' : (cell.state === 2 ? ' question' : ''));
            cell.el.innerText = cell.state === 1 ? 'X' : (cell.state === 2 ? '?' : '');
        }
    }

    function startGame(m) {
        mode = m;
        const w = parseInt(document.getElementById('cfg-w').value);
        const h = parseInt(document.getElementById('cfg-h').value);
        const mines = parseInt(document.getElementById('cfg-m').value);
        
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('game-container').classList.remove('hidden');
        
        boards.player = new Minesweeper('player-grid', w, h, mines, false);
        
        if (mode === 'pvp') {
            document.getElementById('ai-area').classList.remove('hidden');
            document.getElementById('btn-solve').classList.add('hidden');
            boards.ai = new Minesweeper('ai-grid', w, h, mines, true);
        }

        if (document.getElementById('cfg-timed').checked) {
            timeLeft = Math.floor((w * h) / (mines / 8)) + 15;
            updateTimerDisplay();
            timer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                if (timeLeft <= 0) endGame("timer");
            }, 1000);
        }

        gameActive = true;
        setRemark('start');
        updateScore(0);
    }

    async function handleMove(x, y) {
        if (!gameActive || !isPlayerTurn) return;
        
        if (boards.player.firstClick) {
            boards.player.generate(x, y);
            boards.player.firstClick = false;
        }

        boards.player.reveal(x, y);
        updateScore(10);

        if (boards.player.dead) return endGame("lose");
        if (checkWin(boards.player)) return endGame("win");

        if (mode === 'pvp') {
            isPlayerTurn = false;
            await new Promise(r => setTimeout(r, 500));
            doAiTurn();
        }
    }

    function doAiTurn() {
        if (!gameActive) return;
        if (boards.ai.firstClick) {
            boards.ai.generate(0,0);
            boards.ai.firstClick = false;
        }

        // PERFECT AI (Cheats to avoid mines)
        let safeCells = [];
        for(let y=0; y<boards.ai.h; y++) {
            for(let x=0; x<boards.ai.w; x++) {
                if(!boards.ai.grid[y][x].revealed && !boards.ai.grid[y][x].mine) safeCells.push({x,y});
            }
        }

        if (safeCells.length > 0) {
            let pick = safeCells[Math.floor(Math.random() * safeCells.length)];
            boards.ai.reveal(pick.x, pick.y);
        }

        if (checkWin(boards.ai)) return endGame("ai");

        isPlayerTurn = true;
    }

    async function runSolver() {
        if (!gameActive || mode === 'pvp') return;
        document.getElementById('btn-solve').disabled = true;
        setRemark('ai');
        
        while (gameActive) {
            let changed = false;
            for (let y = 0; y < boards.player.h; y++) {
                for (let x = 0; x < boards.player.w; x++) {
                    let cell = boards.player.grid[y][x];
                    if (cell.revealed && cell.adj > 0) {
                        let neighbors = boards.player.getNeighbors(x, y);
                        let hidden = neighbors.filter(n => !boards.player.grid[n.y][n.x].revealed);
                        let flagged = neighbors.filter(n => boards.player.grid[n.y][n.x].state === 1);

                        if (hidden.length === cell.adj && flagged.length < hidden.length) {
                            hidden.forEach(n => {
                                let t = boards.player.grid[n.y][n.x];
                                if (t.state !== 1) { t.state = 0; boards.player.cycleFlag(n.x, n.y); changed = true; }
                            });
                        }
                        if (flagged.length === cell.adj) {
                            for (let n of hidden) {
                                if (boards.player.grid[n.y][n.x].state === 0) {
                                    boards.player.reveal(n.x, n.y); changed = true;
                                    await new Promise(r => setTimeout(r, 50));
                                }
                            }
                        }
                    }
                }
            }

            if (!changed && gameActive) {
                // If stuck, use "Perfect Knowledge" to continue showing solution
                let perfectSafe = [];
                boards.player.grid.forEach((r, y) => r.forEach((c, x) => { 
                    if(!c.revealed && !c.mine && c.state === 0) perfectSafe.push({x,y}) 
                }));
                if (perfectSafe.length) {
                    boards.player.reveal(perfectSafe[0].x, perfectSafe[0].y);
                    changed = true;
                } else break;
            }
            if (checkWin(boards.player)) { endGame("win"); break; }
            await new Promise(r => setTimeout(r, 100));
        }
    }

    function useHint() {
        if (score < 500) { alert("Insufficient points for a hint."); return; }
        score -= 500; updateScore(0);
        let mines = [];
        boards.player.grid.forEach(r => r.forEach(c => { if(c.mine && !c.revealed) mines.push(c) }));
        if(mines.length) {
            let m = mines[Math.floor(Math.random() * mines.length)];
            m.el.classList.add('hint');
            setTimeout(() => m.el.classList.remove('hint'), 2000);
        }
    }

    function checkWin(b) { return b.revealedCount === (b.w * b.h) - b.m; }
    function updateScore(v) { score += v; document.getElementById('stat-score').innerText = score; }
    function updateTimerDisplay() { document.getElementById('stat-time').innerText = timeLeft; }

    function endGame(type) {
        gameActive = false;
        clearInterval(timer);
        setRemark(type);
        
        let msg = "";
        if(type === "win") msg = "Mission accomplished. All clear.";
        else if(type === "lose") msg = "Boom. You've hit a mine.";
        else if(type === "timer") msg = "Time has expired.";
        else if(type === "ai") msg = "The AI has finished its board first.";

        setTimeout(() => alert(msg), 100);

        [boards.player, boards.ai].forEach(b => {
            if (b) b.grid.forEach(r => r.forEach(c => {
                if (c.mine) { c.el.classList.add('mine'); c.el.innerText = 'ðŸ’£'; }
            }));
        });
    }
</script>
</body>
</html>
