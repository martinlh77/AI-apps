<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Concatenator & Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }
        
        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
            transform: scale(1.02);
        }
        
        #fileInput {
            display: none;
        }
        
        .url-input-section {
            margin: 20px 0;
        }
        
        .url-input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        #videoUrlInput {
            flex: 1;
            padding: 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }
        
        #videoUrlInput:focus {
            border-color: #764ba2;
        }
        
        #addUrlBtn {
            flex: none;
            padding: 12px 24px;
        }
        
        .url-tip {
            color: #999;
            font-size: 13px;
            margin: 0;
        }
        
        .file-list {
            margin: 20px 0;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.3s;
        }
        
        .file-item:hover {
            background: #e9ecef;
        }
        
        .file-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .drag-handle {
            cursor: grab;
            font-size: 20px;
            color: #999;
            user-select: none;
        }
        
        .drag-handle:active {
            cursor: grabbing;
        }
        
        .file-item.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }
        
        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .remove-btn:hover {
            background: #c82333;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .btn-convert {
            background: #28a745;
            color: white;
            flex: 1;
        }
        
        .btn-convert:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }
        
        .btn-convert:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #formatSelect {
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #667eea;
            font-size: 16px;
            background: white;
            cursor: pointer;
            outline: none;
            transition: border-color 0.3s;
            min-width: 150px;
        }
        
        #formatSelect:hover {
            border-color: #764ba2;
        }
        
        #formatSelect:focus {
            border-color: #764ba2;
        }
        
        .format-info {
            font-size: 13px;
            color: #999;
            margin-top: 5px;
            font-style: italic;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9ff;
            border-radius: 8px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid #667eea;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            color: #667eea;
        }
        
        .mode-btn:hover {
            background: #f0f2ff;
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #764ba2;
        }
        
        .progress-container {
            display: none;
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }
        
        .status {
            margin-top: 10px;
            padding: 12px;
            border-radius: 8px;
            display: none;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            display: block;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            display: block;
        }
        
        .preview-video {
            width: 100%;
            max-width: 100%;
            border-radius: 8px;
            margin-top: 20px;
            display: none;
        }
        
        #convertSection {
            display: none;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            .upload-area {
                padding: 30px 20px;
            }
            
            .url-input-container {
                flex-direction: column;
            }
            
            #addUrlBtn {
                width: 100%;
            }
            
            .controls {
                flex-direction: column;
            }
            
            #formatSelect {
                width: 100%;
            }
            
            .mode-selector {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Video Concatenator & Converter</h1>
        <p class="subtitle">Combine videos OR convert formats - your choice!</p>
        
        <div class="mode-selector">
            <button class="mode-btn active" id="concatenateMode">
                üìπ Concatenate Videos
            </button>
            <button class="mode-btn" id="convertMode">
                üîÑ Convert Format
            </button>
        </div>
        
        <!-- Concatenate Section (default) -->
        <div id="concatenateSection">
            <div class="upload-area" id="uploadArea">
                <div style="font-size: 48px; margin-bottom: 10px;">üìπ</div>
                <p style="font-size: 18px; margin-bottom: 5px;">Click or drag videos here</p>
                <p style="color: #999; font-size: 14px;">Supports MP4, WebM, and other video formats</p>
                <input type="file" id="fileInput" accept="video/*" multiple>
            </div>
            
            <div class="url-input-section">
                <div class="url-input-container">
                    <input 
                        type="text" 
                        id="videoUrlInput" 
                        placeholder="Paste video URL here (direct link to MP4, WebM, etc.)"
                    >
                    <button class="btn-primary" id="addUrlBtn">
                        Add URL
                    </button>
                </div>
                <p class="url-tip">
                    üí° Tip: The video must be publicly accessible and CORS-enabled. Right-click a video ‚Üí "Copy video address"
                </p>
            </div>
            
            <div class="file-list" id="fileList"></div>
            
            <div class="controls">
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <select id="formatSelect">
                        <option value="webm">WebM (Fast)</option>
                        <option value="mp4">MP4 (Slower)</option>
                    </select>
                    <span class="format-info" id="formatInfo">Fast encoding, good compatibility</span>
                </div>
                <button class="btn-primary" id="combineBtn" disabled>
                    Combine Videos
                </button>
                <button class="btn-secondary" id="clearBtn">
                    Clear All
                </button>
            </div>
        </div>
        
        <!-- Convert Section -->
        <div id="convertSection">
            <div class="upload-area" id="convertUploadArea">
                <div style="font-size: 48px; margin-bottom: 10px;">üîÑ</div>
                <p style="font-size: 18px; margin-bottom: 5px;">Click or drag a single video to convert</p>
                <p style="color: #999; font-size: 14px;">Converts between MP4, WebM, and other formats</p>
                <input type="file" id="convertFileInput" accept="video/*">
            </div>
            
            <div class="file-list" id="convertFileList"></div>
            
            <div class="controls">
                <div style="display: flex; flex-direction: column; gap: 5px; flex: 1;">
                    <label style="font-weight: 600; color: #333; margin-bottom: 5px;">Convert to:</label>
                    <select id="convertFormatSelect" style="padding: 12px; border-radius: 8px; border: 2px solid #667eea; font-size: 16px;">
                        <option value="mp4">MP4 (H.264 + AAC)</option>
                        <option value="webm">WebM (VP9 + Opus)</option>
                        <option value="webm-vp8">WebM (VP8 + Opus)</option>
                    </select>
                </div>
                <button class="btn-convert" id="convertBtn" disabled>
                    Convert Video
                </button>
                <button class="btn-secondary" id="clearConvertBtn">
                    Clear
                </button>
            </div>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
        </div>
        
        <div class="status" id="status"></div>
        
        <video class="preview-video" id="previewVideo" controls></video>
    </div>

    <!-- FFmpeg.wasm -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/index.js"></script>

    <script>
        class VideoConcatenator {
            constructor() {
                this.files = [];
                this.urlVideos = [];
                this.isProcessing = false;
                this.ffmpeg = null;
                this.ffmpegLoaded = false;
                this.currentMode = 'concatenate';
                this.convertFile = null;
                this.init();
            }
            
            init() {
                // Mode switching
                document.getElementById('concatenateMode').addEventListener('click', () => this.switchMode('concatenate'));
                document.getElementById('convertMode').addEventListener('click', () => this.switchMode('convert'));
                
                // Concatenate mode elements
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const combineBtn = document.getElementById('combineBtn');
                const clearBtn = document.getElementById('clearBtn');
                const addUrlBtn = document.getElementById('addUrlBtn');
                const videoUrlInput = document.getElementById('videoUrlInput');
                const formatSelect = document.getElementById('formatSelect');
                
                // Convert mode elements
                const convertUploadArea = document.getElementById('convertUploadArea');
                const convertFileInput = document.getElementById('convertFileInput');
                const convertBtn = document.getElementById('convertBtn');
                const clearConvertBtn = document.getElementById('clearConvertBtn');
                
                // Concatenate mode handlers
                uploadArea.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });
                
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });
                
                addUrlBtn.addEventListener('click', () => this.handleUrl());
                videoUrlInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleUrl();
                });
                
                formatSelect.addEventListener('change', (e) => {
                    const formatInfo = document.getElementById('formatInfo');
                    if (e.target.value === 'webm') {
                        formatInfo.textContent = 'Fast encoding, good compatibility';
                    } else {
                        formatInfo.textContent = 'Best compatibility, requires conversion (slower)';
                    }
                });
                
                combineBtn.addEventListener('click', () => this.combineVideos());
                clearBtn.addEventListener('click', () => this.clearAll());
                
                // Convert mode handlers
                convertUploadArea.addEventListener('click', () => convertFileInput.click());
                convertFileInput.addEventListener('change', (e) => {
                    this.handleConvertFile(e.target.files[0]);
                });
                
                convertUploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    convertUploadArea.classList.add('dragover');
                });
                
                convertUploadArea.addEventListener('dragleave', () => {
                    convertUploadArea.classList.remove('dragover');
                });
                
                convertUploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    convertUploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files.length > 0) {
                        this.handleConvertFile(e.dataTransfer.files[0]);
                    }
                });
                
                convertBtn.addEventListener('click', () => this.convertVideo());
                clearConvertBtn.addEventListener('click', () => this.clearConvert());
            }
            
            switchMode(mode) {
                this.currentMode = mode;
                
                const concatenateMode = document.getElementById('concatenateMode');
                const convertMode = document.getElementById('convertMode');
                const concatenateSection = document.getElementById('concatenateSection');
                const convertSection = document.getElementById('convertSection');
                
                if (mode === 'concatenate') {
                    concatenateMode.classList.add('active');
                    convertMode.classList.remove('active');
                    concatenateSection.style.display = 'block';
                    convertSection.style.display = 'none';
                } else {
                    concatenateMode.classList.remove('active');
                    convertMode.classList.add('active');
                    concatenateSection.style.display = 'none';
                    convertSection.style.display = 'block';
                }
                
                this.hideStatus();
                document.getElementById('previewVideo').style.display = 'none';
            }
            
            handleConvertFile(file) {
                if (!file || !file.type.startsWith('video/')) {
                    this.showStatus('Please select a valid video file', 'error');
                    return;
                }
                
                this.convertFile = file;
                this.renderConvertFile();
                document.getElementById('convertBtn').disabled = false;
                this.hideStatus();
            }
            
            renderConvertFile() {
                const convertFileList = document.getElementById('convertFileList');
                if (!this.convertFile) {
                    convertFileList.innerHTML = '';
                    return;
                }
                
                convertFileList.innerHTML = `
                    <div class="file-item">
                        <div class="file-info">
                            <span>üìÅ ${this.convertFile.name}</span>
                            <span style="color: #999; font-size: 14px;">(${this.formatFileSize(this.convertFile.size)})</span>
                        </div>
                    </div>
                `;
            }
            
            clearConvert() {
                this.convertFile = null;
                this.renderConvertFile();
                document.getElementById('convertBtn').disabled = true;
                document.getElementById('convertFileInput').value = '';
                this.hideStatus();
                document.getElementById('previewVideo').style.display = 'none';
            }
            
            async convertVideo() {
                if (!this.convertFile) {
                    this.showStatus('Please select a video file first', 'error');
                    return;
                }
                
                this.isProcessing = true;
                document.getElementById('convertBtn').disabled = true;
                this.showProgress(0);
                
                try {
                    const targetFormat = document.getElementById('convertFormatSelect').value;
                    
                    let outputBlob;
                    let fileExtension;
                    let mimeType;
                    
                    if (targetFormat === 'mp4') {
                        this.showStatus('Converting to MP4...', 'success');
                        outputBlob = await this.convertToMP4Direct(this.convertFile);
                        fileExtension = 'mp4';
                        mimeType = 'video/mp4';
                    } else if (targetFormat === 'webm') {
                        this.showStatus('Converting to WebM (VP9)...', 'success');
                        outputBlob = await this.convertToWebM(this.convertFile, 'vp9');
                        fileExtension = 'webm';
                        mimeType = 'video/webm';
                    } else if (targetFormat === 'webm-vp8') {
                        this.showStatus('Converting to WebM (VP8)...', 'success');
                        outputBlob = await this.convertToWebM(this.convertFile, 'vp8');
                        fileExtension = 'webm';
                        mimeType = 'video/webm';
                    }
                    
                    this.showProgress(100);
                    
                    // Create download link and preview
                    const url = URL.createObjectURL(outputBlob);
                    const previewVideo = document.getElementById('previewVideo');
                    previewVideo.src = url;
                    previewVideo.style.display = 'block';
                    
                    // Auto-download
                    const originalName = this.convertFile.name.replace(/\.[^/.]+$/, '');
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${originalName}_converted.${fileExtension}`;
                    a.click();
                    
                    this.showStatus(`‚úÖ Video converted to ${targetFormat.toUpperCase()} successfully!`, 'success');
                    
                } catch (error) {
                    console.error('Conversion error:', error);
                    this.showStatus(`Error: ${error.message}`, 'error');
                } finally {
                    this.isProcessing = false;
                    document.getElementById('convertBtn').disabled = false;
                    setTimeout(() => this.hideProgress(), 2000);
                }
            }
            
            async loadFFmpeg() {
                if (this.ffmpegLoaded) return;
                
                this.showStatus('Loading FFmpeg for conversion...', 'success');
                
                try {
                    const { FFmpeg } = FFmpegWASM;
                    this.ffmpeg = new FFmpeg();
                    
                    this.ffmpeg.on('log', ({ message }) => {
                        console.log('FFmpeg:', message);
                    });
                    
                    this.ffmpeg.on('progress', ({ progress }) => {
                        if (progress > 0 && progress < 1) {
                            const percent = Math.round(progress * 100);
                            this.showProgress(percent);
                        }
                    });
                    
                    await this.ffmpeg.load({
                        coreURL: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js',
                        wasmURL: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm',
                    });
                    
                    this.ffmpegLoaded = true;
                    this.hideStatus();
                } catch (error) {
                    console.error('FFmpeg load error:', error);
                    throw new Error('Failed to load FFmpeg: ' + error.message);
                }
            }
            
            async convertToMP4Direct(file) {
                try {
                    if (!this.ffmpegLoaded) {
                        await this.loadFFmpeg();
                    }
                    
                    const { fetchFile } = FFmpegUtil;
                    
                    const inputName = 'input' + this.getFileExtension(file.name);
                    await this.ffmpeg.writeFile(inputName, await fetchFile(file));
                    
                    await this.ffmpeg.exec([
                        '-i', inputName,
                        '-c:v', 'libx264',
                        '-preset', 'medium',
                        '-crf', '23',
                        '-c:a', 'aac',
                        '-b:a', '128k',
                        '-movflags', '+faststart',
                        'output.mp4'
                    ]);
                    
                    const data = await this.ffmpeg.readFile('output.mp4');
                    
                    await this.ffmpeg.deleteFile(inputName);
                    await this.ffmpeg.deleteFile('output.mp4');
                    
                    return new Blob([data.buffer], { type: 'video/mp4' });
                    
                } catch (error) {
                    console.error('MP4 conversion error:', error);
                    throw new Error('MP4 conversion failed: ' + error.message);
                }
            }
            
            async convertToWebM(file, codec = 'vp9') {
                try {
                    if (!this.ffmpegLoaded) {
                        await this.loadFFmpeg();
                    }
                    
                    const { fetchFile } = FFmpegUtil;
                    
                    const inputName = 'input' + this.getFileExtension(file.name);
                    await this.ffmpeg.writeFile(inputName, await fetchFile(file));
                    
                    const codecLib = codec === 'vp9' ? 'libvpx-vp9' : 'libvpx';
                    const crf = codec === 'vp9' ? '31' : '10';
                    
                    await this.ffmpeg.exec([
                        '-i', inputName,
                        '-c:v', codecLib,
                        '-crf', crf,
                        '-b:v', '0',
                        '-c:a', 'libopus',
                        '-b:a', '128k',
                        'output.webm'
                    ]);
                    
                    const data = await this.ffmpeg.readFile('output.webm');
                    
                    await this.ffmpeg.deleteFile(inputName);
                    await this.ffmpeg.deleteFile('output.webm');
                    
                    return new Blob([data.buffer], { type: 'video/webm' });
                    
                } catch (error) {
                    console.error('WebM conversion error:', error);
                    throw new Error('WebM conversion failed: ' + error.message);
                }
            }
            
            getFileExtension(filename) {
                const match = filename.match(/\.[^.]+$/);
                return match ? match[0] : '.mp4';
            }
            
            async convertToMP4(webmBlob) {
                this.showStatus('Converting to MP4... This may take a few minutes.', 'success');
                
                try {
                    if (!this.ffmpegLoaded) {
                        await this.loadFFmpeg();
                    }
                    
                    const { fetchFile } = FFmpegUtil;
                    
                    await this.ffmpeg.writeFile('input.webm', await fetchFile(webmBlob));
                    
                    await this.ffmpeg.exec([
                        '-i', 'input.webm',
                        '-c:v', 'libx264',
                        '-preset', 'medium',
                        '-crf', '23',
                        '-c:a', 'aac',
                        '-b:a', '128k',
                        '-movflags', '+faststart',
                        'output.mp4'
                    ]);
                    
                    const data = await this.ffmpeg.readFile('output.mp4');
                    
                    await this.ffmpeg.deleteFile('input.webm');
                    await this.ffmpeg.deleteFile('output.mp4');
                    
                    return new Blob([data.buffer], { type: 'video/mp4' });
                    
                } catch (error) {
                    console.error('MP4 conversion error:', error);
                    throw new Error('MP4 conversion failed: ' + error.message);
                }
            }
            
            async handleUrl() {
                const input = document.getElementById('videoUrlInput');
                const url = input.value.trim();
                
                if (!url) {
                    this.showStatus('Please enter a URL, genius', 'error');
                    return;
                }
                
                try {
                    new URL(url);
                } catch {
                    this.showStatus('That\'s not a valid URL. Try again.', 'error');
                    return;
                }
                
                this.showStatus('Loading video from URL...', 'success');
                
                try {
                    const testVideo = document.createElement('video');
                    testVideo.crossOrigin = 'anonymous';
                    testVideo.src = url;
                    
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Video loading timeout - URL might be invalid or not CORS-enabled'));
                        }, 10000);
                        
                        testVideo.onloadedmetadata = () => {
                            clearTimeout(timeout);
                            resolve();
                        };
                        
                        testVideo.onerror = () => {
                            clearTimeout(timeout);
                            reject(new Error('Failed to load video - check URL and CORS settings'));
                        };
                    });
                    
                    const urlVideoData = {
                        type: 'url',
                        url: url,
                        name: this.getFilenameFromUrl(url),
                        size: 'Unknown',
                        duration: testVideo.duration
                    };
                    
                    this.urlVideos.push(urlVideoData);
                    this.renderFileList();
                    this.updateCombineButton();
                    this.hideStatus();
                    
                    input.value = '';
                    
                } catch (error) {
                    this.showStatus(`Error: ${error.message}`, 'error');
                    console.error('URL video error:', error);
                }
            }
            
            getFilenameFromUrl(url) {
                try {
                    const urlObj = new URL(url);
                    const pathname = urlObj.pathname;
                    const filename = pathname.substring(pathname.lastIndexOf('/') + 1);
                    return filename || 'URL Video';
                } catch {
                    return 'URL Video';
                }
            }
            
            handleFiles(fileList) {
                const newFiles = Array.from(fileList).filter(file => 
                    file.type.startsWith('video/')
                );
                
                if (newFiles.length === 0) {
                    this.showStatus('Please select valid video files', 'error');
                    return;
                }
                
                this.files.push(...newFiles);
                this.renderFileList();
                this.updateCombineButton();
                this.hideStatus();
            }
            
            renderFileList() {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';
                
                this.files.forEach((file, index) => {
                    const fileItem = this.createFileItem(file, index, 'file');
                    fileList.appendChild(fileItem);
                });
                
                this.urlVideos.forEach((urlVideo, index) => {
                    const fileItem = this.createFileItem(urlVideo, index, 'url');
                    fileList.appendChild(fileItem);
                });
            }
            
            createFileItem(data, index, type) {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.draggable = true;
                fileItem.dataset.index = index;
                fileItem.dataset.type = type;
                
                const displayIndex = document.querySelectorAll('.file-item').length + 1;
                const icon = type === 'url' ? 'üîó' : 'üìÅ';
                const name = type === 'url' ? data.name : data.name;
                const size = type === 'url' ? data.size : this.formatFileSize(data.size);
                
                fileItem.innerHTML = `
                    <div class="file-info">
                        <span class="drag-handle">‚ãÆ‚ãÆ</span>
                        <span>${icon} ${displayIndex}. ${name}</span>
                        <span style="color: #999; font-size: 14px;">(${size})</span>
                    </div>
                    <button class="remove-btn" onclick="videoConcatenator.removeItem(${index}, '${type}')">Remove</button>
                `;
                
                fileItem.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', JSON.stringify({ index, type }));
                    fileItem.classList.add('dragging');
                });
                
                fileItem.addEventListener('dragend', () => {
                    fileItem.classList.remove('dragging');
                });
                
                fileItem.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const draggingItem = document.querySelector('.dragging');
                    if (draggingItem !== fileItem) {
                        const rect = fileItem.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;
                        const fileList = document.getElementById('fileList');
                        if (e.clientY < midpoint) {
                            fileList.insertBefore(draggingItem, fileItem);
                        } else {
                            fileList.insertBefore(draggingItem, fileItem.nextSibling);
                        }
                    }
                });
                
                return fileItem;
            }
            
            removeItem(index, type) {
                if (type === 'file') {
                    this.files.splice(index, 1);
                } else {
                    this.urlVideos.splice(index, 1);
                }
                this.renderFileList();
                this.updateCombineButton();
            }
            
            clearAll() {
                this.files = [];
                this.urlVideos = [];
                this.renderFileList();
                this.updateCombineButton();
                this.hideStatus();
                document.getElementById('previewVideo').style.display = 'none';
                document.getElementById('videoUrlInput').value = '';
            }
            
            updateCombineButton() {
                const combineBtn = document.getElementById('combineBtn');
                const totalVideos = this.files.length + this.urlVideos.length;
                combineBtn.disabled = totalVideos < 2 || this.isProcessing;
            }
            
            async combineVideos() {
                const totalVideos = this.files.length + this.urlVideos.length;
                
                if (totalVideos < 2) {
                    this.showStatus('Add at least 2 videos, genius', 'error');
                    return;
                }
                
                this.isProcessing = true;
                this.updateCombineButton();
                this.showProgress(0);
                
                try {
                    let combinedBlob = await this.concatenateWithCanvas();
                    
                    const format = document.getElementById('formatSelect').value;
                    let fileExtension = 'webm';
                    let mimeType = 'video/webm';
                    
                    if (format === 'mp4') {
                        this.showProgress(95);
                        combinedBlob = await this.convertToMP4(combinedBlob);
                        fileExtension = 'mp4';
                        mimeType = 'video/mp4';
                    }
                    
                    this.showProgress(100);
                    
                    const url = URL.createObjectURL(combinedBlob);
                    const previewVideo = document.getElementById('previewVideo');
                    previewVideo.src = url;
                    previewVideo.style.display = 'block';
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `combined_${Date.now()}.${fileExtension}`;
                    a.click();
                    
                    this.showStatus(`‚úÖ Videos combined successfully as ${fileExtension.toUpperCase()}! Check your downloads.`, 'success');
                    
                } catch (error) {
                    console.error('Concatenation error:', error);
                    this.showStatus(`Error: ${error.message}`, 'error');
                } finally {
                    this.isProcessing = false;
                    this.updateCombineButton();
                    setTimeout(() => this.hideProgress(), 2000);
                }
            }
            
            async concatenateWithCanvas() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const videoElements = [];
                
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const audioDestination = audioCtx.createMediaStreamDestination();
                
                const fileItems = document.querySelectorAll('.file-item');
                const orderedVideos = [];
                
                fileItems.forEach(item => {
                    const index = parseInt(item.dataset.index);
                    const type = item.dataset.type;
                    
                    if (type === 'file') {
                        orderedVideos.push({ type: 'file', data: this.files[index] });
                    } else {
                        orderedVideos.push({ type: 'url', data: this.urlVideos[index] });
                    }
                });
                
                let maxWidth = 0;
                let maxHeight = 0;
                let totalAspectRatio = 0;
                
                for (let i = 0; i < orderedVideos.length; i++) {
                    const videoData = orderedVideos[i];
                    const video = document.createElement('video');
                    video.crossOrigin = 'anonymous';
                    
                    if (videoData.type === 'file') {
                        video.src = URL.createObjectURL(videoData.data);
                    } else {
                        video.src = videoData.data.url;
                    }
                    
                    video.muted = false;
                    
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error(`Timeout loading video ${i + 1}`));
                        }, 15000);
                        
                        video.onloadedmetadata = () => {
                            clearTimeout(timeout);
                            resolve();
                        };
                        video.onerror = () => {
                            clearTimeout(timeout);
                            reject(new Error(`Failed to load video ${i + 1}`));
                        };
                    });
                    
                    videoElements.push(video);
                    
                    maxWidth = Math.max(maxWidth, video.videoWidth);
                    maxHeight = Math.max(maxHeight, video.videoHeight);
                    totalAspectRatio += video.videoWidth / video.videoHeight;
                    
                    try {
                        const source = audioCtx.createMediaElementSource(video);
                        source.connect(audioDestination);
                        source.connect(audioCtx.destination);
                    } catch (e) {
                        console.warn(`No audio track in video ${i + 1}:`, e.message);
                    }
                }
                
                const avgAspectRatio = totalAspectRatio / videoElements.length;
                
                if (avgAspectRatio > 1) {
                    canvas.width = Math.min(maxWidth, 1920);
                    canvas.height = Math.round(canvas.width / avgAspectRatio);
                } else {
                    canvas.height = Math.min(maxHeight, 1920);
                    canvas.width = Math.round(canvas.height * avgAspectRatio);
                }
                
                canvas.width = canvas.width % 2 === 0 ? canvas.width : canvas.width + 1;
                canvas.height = canvas.height % 2 === 0 ? canvas.height : canvas.height + 1;
                
                console.log(`Canvas size: ${canvas.width}x${canvas.height}`);
                
                const stream = canvas.captureStream(30);
                
                const audioTracks = audioDestination.stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    stream.addTrack(audioTracks[0]);
                }
                
                let mimeType = 'video/webm;codecs=vp9,opus';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8,opus';
                }
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm';
                }
                
                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000,
                    audioBitsPerSecond: 128000
                });
                
                const chunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };
                
                mediaRecorder.start(100);
                
                let totalDuration = 0;
                for (const video of videoElements) {
                    totalDuration += video.duration;
                }
                
                let processedDuration = 0;
                
                const drawVideoToCanvas = (video) => {
                    const videoAspect = video.videoWidth / video.videoHeight;
                    const canvasAspect = canvas.width / canvas.height;
                    
                    let drawWidth, drawHeight, offsetX, offsetY;
                    
                    if (videoAspect > canvasAspect) {
                        drawWidth = canvas.width;
                        drawHeight = canvas.width / videoAspect;
                        offsetX = 0;
                        offsetY = (canvas.height - drawHeight) / 2;
                    } else {
                        drawHeight = canvas.height;
                        drawWidth = canvas.height * videoAspect;
                        offsetX = (canvas.width - drawWidth) / 2;
                        offsetY = 0;
                    }
                    
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
                };
                
                for (let i = 0; i < videoElements.length; i++) {
                    const video = videoElements[i];
                    video.currentTime = 0;
                    
                    console.log(`Processing video ${i + 1}: ${video.videoWidth}x${video.videoHeight}`);
                    
                    await new Promise((resolve) => {
                        let animationId;
                        
                        const drawFrame = () => {
                            if (!video.paused && !video.ended) {
                                drawVideoToCanvas(video);
                                
                                const currentProgress = ((processedDuration + video.currentTime) / totalDuration) * 95;
                                this.showProgress(Math.min(95, currentProgress));
                                
                                animationId = requestAnimationFrame(drawFrame);
                            }
                        };
                        
                        video.onended = () => {
                            cancelAnimationFrame(animationId);
                            processedDuration += video.duration;
                            video.pause();
                            resolve();
                        };
                        
                        video.onerror = (e) => {
                            cancelAnimationFrame(animationId);
                            console.error('Video playback error:', e);
                            resolve();
                        };
                        
                        video.play().then(() => {
                            drawFrame();
                        }).catch(err => {
                            console.error('Play error:', err);
                            resolve();
                        });
                    });
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                drawVideoToCanvas(videoElements[videoElements.length - 1]);
                
                mediaRecorder.stop();
                
                const blob = await new Promise((resolve) => {
                    mediaRecorder.onstop = () => {
                        resolve(new Blob(chunks, { type: mimeType }));
                    };
                    
                    setTimeout(() => {
                        if (chunks.length > 0) {
                            resolve(new Blob(chunks, { type: mimeType }));
                        }
                    }, 1000);
                });
                
                videoElements.forEach((video, index) => {
                    const videoData = orderedVideos[index];
                    if (videoData.type === 'file') {
                        URL.revokeObjectURL(video.src);
                    }
                    video.src = '';
                });
                
                audioCtx.close();
                
                return blob;
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
            }
            
            showProgress(percent) {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                progressContainer.style.display = 'block';
                progressFill.style.width = percent + '%';
                progressFill.textContent = Math.round(percent) + '%';
            }
            
            hideProgress() {
                document.getElementById('progressContainer').style.display = 'none';
            }
            
            showStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }
            
            hideStatus() {
                const status = document.getElementById('status');
                status.className = 'status';
            }
        }
        
        const videoConcatenator = new VideoConcatenator();
    </script>
</body>
</html>
