<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Concatenator & Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }

        /* Tab Styles */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab:hover {
            color: #667eea;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }
        
        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
            transform: scale(1.02);
        }
        
        #fileInput, #convertFileInput {
            display: none;
        }
        
        .url-input-section {
            margin: 20px 0;
        }
        
        .url-input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        #videoUrlInput {
            flex: 1;
            padding: 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }
        
        #videoUrlInput:focus {
            border-color: #764ba2;
        }
        
        #addUrlBtn {
            flex: none;
            padding: 12px 24px;
        }
        
        .url-tip {
            color: #999;
            font-size: 13px;
            margin: 0;
        }
        
        .file-list {
            margin: 20px 0;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.3s;
        }
        
        .file-item:hover {
            background: #e9ecef;
        }
        
        .file-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .drag-handle {
            cursor: grab;
            font-size: 20px;
            color: #999;
            user-select: none;
        }
        
        .drag-handle:active {
            cursor: grabbing;
        }
        
        .file-item.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }
        
        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .remove-btn:hover {
            background: #c82333;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .progress-container {
            display: none;
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }
        
        .status {
            margin-top: 10px;
            padding: 12px;
            border-radius: 8px;
            display: none;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            display: block;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            display: block;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
            display: block;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            display: block;
        }
        
        .preview-video {
            width: 100%;
            max-width: 100%;
            border-radius: 8px;
            margin-top: 20px;
            display: none;
        }

        .format-selector {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9ff;
            border-radius: 8px;
        }

        .format-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .format-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .format-option {
            flex: 1;
            min-width: 120px;
        }

        .format-option input[type="radio"] {
            display: none;
        }

        .format-option label {
            display: block;
            padding: 12px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            color: #667eea;
        }

        .format-option input[type="radio"]:checked + label {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .format-option label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .convert-section {
            margin: 20px 0;
        }

        .video-info {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .video-info-details {
            flex: 1;
        }

        .video-info p {
            margin: 5px 0;
            color: #666;
        }

        .video-info strong {
            color: #333;
        }

        .ffmpeg-notice {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            font-size: 14px;
            color: #0d47a1;
        }

        .ffmpeg-notice strong {
            display: block;
            margin-bottom: 8px;
            color: #1565c0;
        }

        .ffmpeg-notice ul {
            margin: 10px 0 0 20px;
        }

        .ffmpeg-notice li {
            margin: 5px 0;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            .upload-area {
                padding: 30px 20px;
            }
            
            .url-input-container {
                flex-direction: column;
            }
            
            #addUrlBtn {
                width: 100%;
            }

            .tabs {
                flex-direction: column;
                gap: 5px;
            }

            .tab {
                text-align: left;
            }

            .video-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Video Concatenator & Converter</h1>
        <p class="subtitle">Because apparently combining and converting videos is rocket science</p>
        
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" data-tab="concat">Concatenate Videos</button>
            <button class="tab" data-tab="convert">Convert Format</button>
        </div>

        <!-- Concatenate Tab -->
        <div id="concatTab" class="tab-content active">
            <div class="ffmpeg-notice">
                <strong>üì¶ MP4 Export Notice:</strong>
                When selecting MP4 format, FFmpeg will be loaded (~31MB download, one-time only). 
                This may take a moment on first use. Processing will be slower than WebM but produces true MP4/H.264 output.
            </div>

            <div class="upload-area" id="uploadArea">
                <div style="font-size: 48px; margin-bottom: 10px;">üìπ</div>
                <p style="font-size: 18px; margin-bottom: 5px;">Click or drag videos here</p>
                <p style="color: #999; font-size: 14px;">Supports MP4, WebM, and other video formats</p>
                <input type="file" id="fileInput" accept="video/*" multiple>
            </div>
            
            <div class="url-input-section">
                <div class="url-input-container">
                    <input 
                        type="text" 
                        id="videoUrlInput" 
                        placeholder="Paste video URL here (direct link to MP4, WebM, etc.)"
                    >
                    <button class="btn-primary" id="addUrlBtn">
                        Add URL
                    </button>
                </div>
                <p class="url-tip">
                    üí° Tip: The video must be publicly accessible and CORS-enabled. Right-click a video ‚Üí "Copy video address"
                </p>
            </div>
            
            <div class="file-list" id="fileList"></div>

            <div class="format-selector">
                <label>Output Format:</label>
                <div class="format-options">
                    <div class="format-option">
                        <input type="radio" id="formatWebM" name="outputFormat" value="webm" checked>
                        <label for="formatWebM">WebM (Fast)</label>
                    </div>
                    <div class="format-option">
                        <input type="radio" id="formatMP4" name="outputFormat" value="mp4">
                        <label for="formatMP4">MP4 (Slower)</label>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button class="btn-primary" id="combineBtn" disabled>
                    Combine Videos
                </button>
                <button class="btn-secondary" id="clearBtn">
                    Clear All
                </button>
            </div>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
            </div>
            
            <div class="status" id="status"></div>
            
            <video class="preview-video" id="previewVideo" controls></video>
        </div>

        <!-- Convert Tab -->
        <div id="convertTab" class="tab-content">
            <div class="ffmpeg-notice">
                <strong>üì¶ MP4 Conversion Notice:</strong>
                MP4 conversion uses FFmpeg (~31MB download, one-time only). Processing is slower than WebM but produces true MP4/H.264 output compatible with all platforms.
            </div>

            <div class="upload-area" id="convertUploadArea">
                <div style="font-size: 48px; margin-bottom: 10px;">üîÑ</div>
                <p style="font-size: 18px; margin-bottom: 5px;">Click or drag a video to convert</p>
                <p style="color: #999; font-size: 14px;">Convert between WebM and MP4</p>
                <input type="file" id="convertFileInput" accept="video/*">
            </div>

            <div class="url-input-section">
                <div class="url-input-container">
                    <input 
                        type="text" 
                        id="convertVideoUrlInput" 
                        placeholder="Or paste video URL here"
                    >
                    <button class="btn-primary" id="convertAddUrlBtn">
                        Load URL
                    </button>
                </div>
                <p class="url-tip">
                    üí° For hosted pages: Ensure the video URL is CORS-enabled
                </p>
            </div>

            <div class="video-info" id="convertVideoInfo" style="display: none;">
                <div class="video-info-details">
                    <p><strong>File:</strong> <span id="convertFileName"></span></p>
                    <p><strong>Size:</strong> <span id="convertFileSize"></span></p>
                    <p><strong>Duration:</strong> <span id="convertFileDuration"></span></p>
                </div>
                <button class="remove-btn" id="convertRemoveBtn">Remove</button>
            </div>

            <div class="format-selector">
                <label>Convert To:</label>
                <div class="format-options">
                    <div class="format-option">
                        <input type="radio" id="convertFormatWebM" name="convertFormat" value="webm" checked>
                        <label for="convertFormatWebM">WebM (Fast)</label>
                    </div>
                    <div class="format-option">
                        <input type="radio" id="convertFormatMP4" name="convertFormat" value="mp4">
                        <label for="convertFormatMP4">MP4 (Slower)</label>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button class="btn-primary" id="convertBtn" disabled>
                    Convert Video
                </button>
                <button class="btn-secondary" id="convertClearBtn">
                    Clear
                </button>
            </div>

            <div class="progress-container" id="convertProgressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="convertProgressFill">0%</div>
                </div>
            </div>

            <div class="status" id="convertStatus"></div>

            <video class="preview-video" id="convertPreviewVideo" controls></video>
        </div>
    </div>

    <script type="module">
        import { FFmpeg } from 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm/ffmpeg.js';
        import { fetchFile, toBlobURL } from 'https://unpkg.com/@ffmpeg/util@0.12.1/dist/esm/index.js';

        // Make FFmpeg available globally
        window.FFmpegLib = { FFmpeg, fetchFile, toBlobURL };
        window.ffmpegInstance = null;
        window.ffmpegLoaded = false;

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const tabName = tab.dataset.tab;
                document.getElementById(tabName + 'Tab').classList.add('active');
            });
        });

        // Shared FFmpeg loader
        async function loadFFmpeg(statusCallback) {
            if (window.ffmpegLoaded) {
                return window.ffmpegInstance;
            }

            try {
                statusCallback('Loading FFmpeg (~31MB, one-time download)...', 'info');
                
                const ffmpeg = new window.FFmpegLib.FFmpeg();
                
                ffmpeg.on('log', ({ message }) => {
                    console.log('FFmpeg:', message);
                });

                ffmpeg.on('progress', ({ progress, time }) => {
                    const percent = Math.round(progress * 100);
                    if (percent > 0) {
                        statusCallback(`Processing: ${percent}%`, 'info');
                    }
                });

                const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm';
                await ffmpeg.load({
                    coreURL: await window.FFmpegLib.toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                    wasmURL: await window.FFmpegLib.toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                });

                window.ffmpegInstance = ffmpeg;
                window.ffmpegLoaded = true;
                
                statusCallback('FFmpeg loaded successfully!', 'success');
                return ffmpeg;
            } catch (error) {
                console.error('FFmpeg load error:', error);
                throw new Error('Failed to load FFmpeg: ' + error.message);
            }
        }

        // Video Concatenator
        class VideoConcatenator {
            constructor() {
                this.files = [];
                this.urlVideos = [];
                this.isProcessing = false;
                this.init();
            }
            
            init() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const combineBtn = document.getElementById('combineBtn');
                const clearBtn = document.getElementById('clearBtn');
                const addUrlBtn = document.getElementById('addUrlBtn');
                const videoUrlInput = document.getElementById('videoUrlInput');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                
                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });
                
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });
                
                addUrlBtn.addEventListener('click', () => this.handleUrl());
                videoUrlInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleUrl();
                });
                
                combineBtn.addEventListener('click', () => this.combineVideos());
                clearBtn.addEventListener('click', () => this.clearAll());
            }
            
            async handleUrl() {
                const input = document.getElementById('videoUrlInput');
                const url = input.value.trim();
                
                if (!url) {
                    this.showStatus('Please enter a URL', 'error');
                    return;
                }
                
                try {
                    new URL(url);
                } catch {
                    this.showStatus('That\'s not a valid URL. Try again.', 'error');
                    return;
                }
                
                this.showStatus('Loading video from URL...', 'info');
                
                try {
                    const testVideo = document.createElement('video');
                    testVideo.crossOrigin = 'anonymous';
                    testVideo.src = url;
                    
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Video loading timeout - URL might be invalid or not CORS-enabled'));
                        }, 10000);
                        
                        testVideo.onloadedmetadata = () => {
                            clearTimeout(timeout);
                            resolve();
                        };
                        
                        testVideo.onerror = () => {
                            clearTimeout(timeout);
                            reject(new Error('Failed to load video - check URL and CORS settings'));
                        };
                    });
                    
                    const urlVideoData = {
                        type: 'url',
                        url: url,
                        name: this.getFilenameFromUrl(url),
                        size: 'Unknown',
                        duration: testVideo.duration
                    };
                    
                    this.urlVideos.push(urlVideoData);
                    this.renderFileList();
                    this.updateCombineButton();
                    this.hideStatus();
                    
                    input.value = '';
                    
                } catch (error) {
                    this.showStatus(`Error: ${error.message}`, 'error');
                    console.error('URL video error:', error);
                }
            }
            
            getFilenameFromUrl(url) {
                try {
                    const urlObj = new URL(url);
                    const pathname = urlObj.pathname;
                    const filename = pathname.substring(pathname.lastIndexOf('/') + 1);
                    return filename || 'URL Video';
                } catch {
                    return 'URL Video';
                }
            }
            
            handleFiles(fileList) {
                const newFiles = Array.from(fileList).filter(file => 
                    file.type.startsWith('video/')
                );
                
                if (newFiles.length === 0) {
                    this.showStatus('Please select valid video files', 'error');
                    return;
                }
                
                this.files.push(...newFiles);
                this.renderFileList();
                this.updateCombineButton();
                this.hideStatus();
            }
            
            renderFileList() {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';
                
                this.files.forEach((file, index) => {
                    const fileItem = this.createFileItem(file, index, 'file');
                    fileList.appendChild(fileItem);
                });
                
                this.urlVideos.forEach((urlVideo, index) => {
                    const fileItem = this.createFileItem(urlVideo, index, 'url');
                    fileList.appendChild(fileItem);
                });
            }
            
            createFileItem(data, index, type) {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.draggable = true;
                fileItem.dataset.index = index;
                fileItem.dataset.type = type;
                
                const displayIndex = document.querySelectorAll('.file-item').length + 1;
                const icon = type === 'url' ? 'üîó' : 'üìÅ';
                const name = type === 'url' ? data.name : data.name;
                const size = type === 'url' ? data.size : this.formatFileSize(data.size);
                
                fileItem.innerHTML = `
                    <div class="file-info">
                        <span class="drag-handle">‚ãÆ‚ãÆ</span>
                        <span>${icon} ${displayIndex}. ${name}</span>
                        <span style="color: #999; font-size: 14px;">(${size})</span>
                    </div>
                    <button class="remove-btn" onclick="videoConcatenator.removeItem(${index}, '${type}')">Remove</button>
                `;
                
                fileItem.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', JSON.stringify({ index, type }));
                    fileItem.classList.add('dragging');
                });
                
                fileItem.addEventListener('dragend', () => {
                    fileItem.classList.remove('dragging');
                });
                
                fileItem.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const draggingItem = document.querySelector('.dragging');
                    if (draggingItem !== fileItem) {
                        const rect = fileItem.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;
                        if (e.clientY < midpoint) {
                            fileList.insertBefore(draggingItem, fileItem);
                        } else {
                            fileList.insertBefore(draggingItem, fileItem.nextSibling);
                        }
                    }
                });
                
                return fileItem;
            }
            
            removeItem(index, type) {
                if (type === 'file') {
                    this.files.splice(index, 1);
                } else {
                    this.urlVideos.splice(index, 1);
                }
                this.renderFileList();
                this.updateCombineButton();
            }
            
            clearAll() {
                this.files = [];
                this.urlVideos = [];
                this.renderFileList();
                this.updateCombineButton();
                this.hideStatus();
                document.getElementById('previewVideo').style.display = 'none';
                document.getElementById('videoUrlInput').value = '';
            }
            
            updateCombineButton() {
                const combineBtn = document.getElementById('combineBtn');
                const totalVideos = this.files.length + this.urlVideos.length;
                combineBtn.disabled = totalVideos < 2 || this.isProcessing;
            }
            
            async combineVideos() {
                const totalVideos = this.files.length + this.urlVideos.length;
                
                if (totalVideos < 2) {
                    this.showStatus('Add at least 2 videos', 'error');
                    return;
                }

                const outputFormat = document.querySelector('input[name="outputFormat"]:checked').value;
                
                this.isProcessing = true;
                this.updateCombineButton();
                this.showProgress(0);
                
                try {
                    let combinedBlob;
                    
                    if (outputFormat === 'mp4') {
                        combinedBlob = await this.combineWithFFmpeg();
                    } else {
                        combinedBlob = await this.concatenateWithCanvas();
                    }
                    
                    this.showProgress(100);
                    
                    const url = URL.createObjectURL(combinedBlob);
                    const previewVideo = document.getElementById('previewVideo');
                    previewVideo.src = url;
                    previewVideo.style.display = 'block';
                    
                    const extension = outputFormat === 'mp4' ? 'mp4' : 'webm';
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `combined_${Date.now()}.${extension}`;
                    a.click();
                    
                    this.showStatus(`‚úÖ Videos combined successfully as ${extension.toUpperCase()}! Check your downloads.`, 'success');
                    
                } catch (error) {
                    console.error('Concatenation error:', error);
                    this.showStatus(`Error: ${error.message}`, 'error');
                } finally {
                    this.isProcessing = false;
                    this.updateCombineButton();
                    setTimeout(() => this.hideProgress(), 2000);
                }
            }

            async combineWithFFmpeg() {
                // First, create intermediate WebM videos
                this.showStatus('Step 1/2: Creating intermediate videos...', 'info');
                const fileItems = document.querySelectorAll('#fileList .file-item');
                const orderedVideos = [];
                
                fileItems.forEach(item => {
                    const index = parseInt(item.dataset.index);
                    const type = item.dataset.type;
                    
                    if (type === 'file') {
                        orderedVideos.push({ type: 'file', data: this.files[index] });
                    } else {
                        orderedVideos.push({ type: 'url', data: this.urlVideos[index] });
                    }
                });

                const webmBlobs = [];
                for (let i = 0; i < orderedVideos.length; i++) {
                    this.showStatus(`Creating intermediate video ${i + 1}/${orderedVideos.length}...`, 'info');
                    const blob = await this.createSingleVideoBlob(orderedVideos[i]);
                    webmBlobs.push(blob);
                    this.showProgress(((i + 1) / orderedVideos.length) * 40);
                }

                // Now use FFmpeg to concatenate and convert to MP4
                this.showStatus('Step 2/2: Converting to MP4 with FFmpeg...', 'info');
                const ffmpeg = await loadFFmpeg((msg, type) => this.showStatus(msg, type));

                try {
                    // Write all videos to FFmpeg filesystem
                    const fileListContent = [];
                    for (let i = 0; i < webmBlobs.length; i++) {
                        const filename = `input${i}.webm`;
                        await ffmpeg.writeFile(filename, await window.FFmpegLib.fetchFile(webmBlobs[i]));
                        fileListContent.push(`file '${filename}'`);
                    }

                    // Create concat demuxer file list
                    await ffmpeg.writeFile('filelist.txt', fileListContent.join('\n'));

                    // Run FFmpeg concatenation
                    this.showStatus('Converting to MP4... This may take a while.', 'info');
                    await ffmpeg.exec([
                        '-f', 'concat',
                        '-safe', '0',
                        '-i', 'filelist.txt',
                        '-c:v', 'libx264',
                        '-preset', 'medium',
                        '-crf', '23',
                        '-c:a', 'aac',
                        '-b:a', '128k',
                        'output.mp4'
                    ]);

                    // Read the output
                    const data = await ffmpeg.readFile('output.mp4');
                    const blob = new Blob([data.buffer], { type: 'video/mp4' });

                    // Cleanup
                    for (let i = 0; i < webmBlobs.length; i++) {
                        await ffmpeg.deleteFile(`input${i}.webm`);
                    }
                    await ffmpeg.deleteFile('filelist.txt');
                    await ffmpeg.deleteFile('output.mp4');

                    return blob;
                } catch (error) {
                    console.error('FFmpeg error:', error);
                    throw new Error('FFmpeg conversion failed: ' + error.message);
                }
            }

            async createSingleVideoBlob(videoData) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                
                if (videoData.type === 'file') {
                    video.src = URL.createObjectURL(videoData.data);
                } else {
                    video.src = videoData.data.url;
                }
                
                video.muted = false;
                
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Timeout loading video')), 15000);
                    video.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    video.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('Failed to load video'));
                    };
                });

                canvas.width = video.videoWidth % 2 === 0 ? video.videoWidth : video.videoWidth + 1;
                canvas.height = video.videoHeight % 2 === 0 ? video.videoHeight : video.videoHeight + 1;

                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const audioDestination = audioCtx.createMediaStreamDestination();

                try {
                    const source = audioCtx.createMediaElementSource(video);
                    source.connect(audioDestination);
                    source.connect(audioCtx.destination);
                } catch (e) {
                    console.warn('No audio track:', e.message);
                }

                const stream = canvas.captureStream(30);
                const audioTracks = audioDestination.stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    stream.addTrack(audioTracks[0]);
                }

                let mimeType = 'video/webm;codecs=vp9,opus';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8,opus';
                }
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm';
                }

                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000,
                    audioBitsPerSecond: 128000
                });

                const chunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };

                mediaRecorder.start(100);

                await new Promise((resolve) => {
                    let animationId;

                    const drawFrame = () => {
                        if (!video.paused && !video.ended) {
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            animationId = requestAnimationFrame(drawFrame);
                        }
                    };

                    video.onended = () => {
                        cancelAnimationFrame(animationId);
                        video.pause();
                        resolve();
                    };

                    video.onerror = () => {
                        cancelAnimationFrame(animationId);
                        resolve();
                    };

                    video.currentTime = 0;
                    video.play().then(() => drawFrame()).catch(() => resolve());
                });

                mediaRecorder.stop();

                const blob = await new Promise((resolve) => {
                    mediaRecorder.onstop = () => {
                        resolve(new Blob(chunks, { type: mimeType }));
                    };
                    setTimeout(() => {
                        if (chunks.length > 0) {
                            resolve(new Blob(chunks, { type: mimeType }));
                        }
                    }, 1000);
                });

                if (videoData.type === 'file') {
                    URL.revokeObjectURL(video.src);
                }
                video.src = '';
                audioCtx.close();

                return blob;
            }
            
            async concatenateWithCanvas() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const videoElements = [];
                
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const audioDestination = audioCtx.createMediaStreamDestination();
                
                const fileItems = document.querySelectorAll('#fileList .file-item');
                const orderedVideos = [];
                
                fileItems.forEach(item => {
                    const index = parseInt(item.dataset.index);
                    const type = item.dataset.type;
                    
                    if (type === 'file') {
                        orderedVideos.push({ type: 'file', data: this.files[index] });
                    } else {
                        orderedVideos.push({ type: 'url', data: this.urlVideos[index] });
                    }
                });
                
                let maxWidth = 0;
                let maxHeight = 0;
                let totalAspectRatio = 0;
                
                for (let i = 0; i < orderedVideos.length; i++) {
                    const videoData = orderedVideos[i];
                    const video = document.createElement('video');
                    video.crossOrigin = 'anonymous';
                    
                    if (videoData.type === 'file') {
                        video.src = URL.createObjectURL(videoData.data);
                    } else {
                        video.src = videoData.data.url;
                    }
                    
                    video.muted = false;
                    
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error(`Timeout loading video ${i + 1}`));
                        }, 15000);
                        
                        video.onloadedmetadata = () => {
                            clearTimeout(timeout);
                            resolve();
                        };
                        video.onerror = () => {
                            clearTimeout(timeout);
                            reject(new Error(`Failed to load video ${i + 1}`));
                        };
                    });
                    
                    videoElements.push(video);
                    
                    maxWidth = Math.max(maxWidth, video.videoWidth);
                    maxHeight = Math.max(maxHeight, video.videoHeight);
                    totalAspectRatio += video.videoWidth / video.videoHeight;
                    
                    try {
                        const source = audioCtx.createMediaElementSource(video);
                        source.connect(audioDestination);
                        source.connect(audioCtx.destination);
                    } catch (e) {
                        console.warn(`No audio track in video ${i + 1}:`, e.message);
                    }
                }
                
                const avgAspectRatio = totalAspectRatio / videoElements.length;
                
                if (avgAspectRatio > 1) {
                    canvas.width = Math.min(maxWidth, 1920);
                    canvas.height = Math.round(canvas.width / avgAspectRatio);
                } else {
                    canvas.height = Math.min(maxHeight, 1920);
                    canvas.width = Math.round(canvas.height * avgAspectRatio);
                }
                
                canvas.width = canvas.width % 2 === 0 ? canvas.width : canvas.width + 1;
                canvas.height = canvas.height % 2 === 0 ? canvas.height : canvas.height + 1;
                
                const stream = canvas.captureStream(30);
                
                const audioTracks = audioDestination.stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    stream.addTrack(audioTracks[0]);
                }
                
                let mimeType = 'video/webm;codecs=vp9,opus';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8,opus';
                }
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm';
                }
                
                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000,
                    audioBitsPerSecond: 128000
                });
                
                const chunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };
                
                mediaRecorder.start(100);
                
                let totalDuration = 0;
                for (const video of videoElements) {
                    totalDuration += video.duration;
                }
                
                let processedDuration = 0;
                
                const drawVideoToCanvas = (video) => {
                    const videoAspect = video.videoWidth / video.videoHeight;
                    const canvasAspect = canvas.width / canvas.height;
                    
                    let drawWidth, drawHeight, offsetX, offsetY;
                    
                    if (videoAspect > canvasAspect) {
                        drawWidth = canvas.width;
                        drawHeight = canvas.width / videoAspect;
                        offsetX = 0;
                        offsetY = (canvas.height - drawHeight) / 2;
                    } else {
                        drawHeight = canvas.height;
                        drawWidth = canvas.height * videoAspect;
                        offsetX = (canvas.width - drawWidth) / 2;
                        offsetY = 0;
                    }
                    
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
                };
                
                for (let i = 0; i < videoElements.length; i++) {
                    const video = videoElements[i];
                    video.currentTime = 0;
                    
                    await new Promise((resolve) => {
                        let animationId;
                        
                        const drawFrame = () => {
                            if (!video.paused && !video.ended) {
                                drawVideoToCanvas(video);
                                
                                const currentProgress = ((processedDuration + video.currentTime) / totalDuration) * 100;
                                this.showProgress(Math.min(95, currentProgress));
                                
                                animationId = requestAnimationFrame(drawFrame);
                            }
                        };
                        
                        video.onended = () => {
                            cancelAnimationFrame(animationId);
                            processedDuration += video.duration;
                            video.pause();
                            resolve();
                        };
                        
                        video.onerror = (e) => {
                            cancelAnimationFrame(animationId);
                            console.error('Video playback error:', e);
                            resolve();
                        };
                        
                        video.play().then(() => {
                            drawFrame();
                        }).catch(err => {
                            console.error('Play error:', err);
                            resolve();
                        });
                    });
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                drawVideoToCanvas(videoElements[videoElements.length - 1]);
                
                mediaRecorder.stop();
                
                const blob = await new Promise((resolve) => {
                    mediaRecorder.onstop = () => {
                        resolve(new Blob(chunks, { type: mimeType }));
                    };
                    
                    setTimeout(() => {
                        if (chunks.length > 0) {
                            resolve(new Blob(chunks, { type: mimeType }));
                        }
                    }, 1000);
                });
                
                videoElements.forEach((video, index) => {
                    const videoData = orderedVideos[index];
                    if (videoData.type === 'file') {
                        URL.revokeObjectURL(video.src);
                    }
                    video.src = '';
                });
                
                audioCtx.close();
                
                return blob;
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
            }
            
            showProgress(percent) {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                progressContainer.style.display = 'block';
                progressFill.style.width = percent + '%';
                progressFill.textContent = Math.round(percent) + '%';
            }
            
            hideProgress() {
                document.getElementById('progressContainer').style.display = 'none';
            }
            
            showStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }
            
            hideStatus() {
                const status = document.getElementById('status');
                status.className = 'status';
            }
        }

        // Video Converter
        class VideoConverter {
            constructor() {
                this.currentFile = null;
                this.currentUrl = null;
                this.isProcessing = false;
                this.init();
            }

            init() {
                const convertUploadArea = document.getElementById('convertUploadArea');
                const convertFileInput = document.getElementById('convertFileInput');
                const convertBtn = document.getElementById('convertBtn');
                const convertClearBtn = document.getElementById('convertClearBtn');
                const convertRemoveBtn = document.getElementById('convertRemoveBtn');
                const convertAddUrlBtn = document.getElementById('convertAddUrlBtn');
                const convertVideoUrlInput = document.getElementById('convertVideoUrlInput');

                convertUploadArea.addEventListener('click', () => convertFileInput.click());

                convertFileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFile(e.target.files[0]);
                    }
                });

                convertUploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    convertUploadArea.classList.add('dragover');
                });

                convertUploadArea.addEventListener('dragleave', () => {
                    convertUploadArea.classList.remove('dragover');
                });

                convertUploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    convertUploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files.length > 0) {
                        this.handleFile(e.dataTransfer.files[0]);
                    }
                });

                convertAddUrlBtn.addEventListener('click', () => this.handleUrl());
                convertVideoUrlInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleUrl();
                });

                convertBtn.addEventListener('click', () => this.convertVideo());
                convertClearBtn.addEventListener('click', () => this.clear());
                convertRemoveBtn.addEventListener('click', () => this.clear());
            }

            async handleUrl() {
                const input = document.getElementById('convertVideoUrlInput');
                const url = input.value.trim();

                if (!url) {
                    this.showStatus('Please enter a URL', 'error');
                    return;
                }

                try {
                    new URL(url);
                } catch {
                    this.showStatus('Invalid URL', 'error');
                    return;
                }

                this.showStatus('Loading video from URL...', 'info');

                try {
                    const testVideo = document.createElement('video');
                    testVideo.crossOrigin = 'anonymous';
                    testVideo.src = url;

                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Video loading timeout - check URL and CORS settings'));
                        }, 10000);

                        testVideo.onloadedmetadata = () => {
                            clearTimeout(timeout);
                            resolve();
                        };

                        testVideo.onerror = () => {
                            clearTimeout(timeout);
                            reject(new Error('Failed to load video - check URL and CORS settings'));
                        };
                    });

                    this.currentUrl = url;
                    this.currentFile = null;
                    this.showVideoInfo(this.getFilenameFromUrl(url), 'Unknown', testVideo.duration);
                    this.updateConvertButton();
                    this.hideStatus();
                    input.value = '';

                } catch (error) {
                    this.showStatus(`Error: ${error.message}`, 'error');
                }
            }

            getFilenameFromUrl(url) {
                try {
                    const urlObj = new URL(url);
                    const pathname = urlObj.pathname;
                    const filename = pathname.substring(pathname.lastIndexOf('/') + 1);
                    return filename || 'URL Video';
                } catch {
                    return 'URL Video';
                }
            }

            async handleFile(file) {
                if (!file.type.startsWith('video/')) {
                    this.showStatus('Please select a valid video file', 'error');
                    return;
                }

                this.currentFile = file;
                this.currentUrl = null;

                const video = document.createElement('video');
                video.src = URL.createObjectURL(file);

                await new Promise((resolve) => {
                    video.onloadedmetadata = () => resolve();
                });

                this.showVideoInfo(file.name, this.formatFileSize(file.size), video.duration);
                this.updateConvertButton();
                this.hideStatus();

                URL.revokeObjectURL(video.src);
            }

            showVideoInfo(name, size, duration) {
                document.getElementById('convertVideoInfo').style.display = 'flex';
                document.getElementById('convertFileName').textContent = name;
                document.getElementById('convertFileSize').textContent = size;
                document.getElementById('convertFileDuration').textContent = this.formatDuration(duration);
            }

            formatDuration(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
            }

            updateConvertButton() {
                const convertBtn = document.getElementById('convertBtn');
                convertBtn.disabled = (!this.currentFile && !this.currentUrl) || this.isProcessing;
            }

            async convertVideo() {
                if (!this.currentFile && !this.currentUrl) {
                    this.showStatus('No video loaded', 'error');
                    return;
                }

                const outputFormat = document.querySelector('input[name="convertFormat"]:checked').value;

                this.isProcessing = true;
                this.updateConvertButton();
                this.showProgress(0);

                try {
                    let convertedBlob;
                    
                    if (outputFormat === 'mp4') {
                        convertedBlob = await this.convertWithFFmpeg();
                    } else {
                        convertedBlob = await this.performConversion();
                    }

                    this.showProgress(100);

                    const url = URL.createObjectURL(convertedBlob);
                    const previewVideo = document.getElementById('convertPreviewVideo');
                    previewVideo.src = url;
                    previewVideo.style.display = 'block';

                    const extension = outputFormat === 'mp4' ? 'mp4' : 'webm';
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `converted_${Date.now()}.${extension}`;
                    a.click();

                    this.showStatus(`‚úÖ Video converted to ${extension.toUpperCase()} successfully!`, 'success');

                } catch (error) {
                    console.error('Conversion error:', error);
                    this.showStatus(`Error: ${error.message}`, 'error');
                } finally {
                    this.isProcessing = false;
                    this.updateConvertButton();
                    setTimeout(() => this.hideProgress(), 2000);
                }
            }

            async convertWithFFmpeg() {
                // First create WebM
                this.showStatus('Step 1/2: Creating intermediate video...', 'info');
                const webmBlob = await this.performConversion();

                // Load FFmpeg and convert to MP4
                this.showStatus('Step 2/2: Converting to MP4 with FFmpeg...', 'info');
                const ffmpeg = await loadFFmpeg((msg, type) => this.showStatus(msg, type));

                try {
                    await ffmpeg.writeFile('input.webm', await window.FFmpegLib.fetchFile(webmBlob));

                    this.showStatus('Converting to MP4... This may take a while.', 'info');
                    await ffmpeg.exec([
                        '-i', 'input.webm',
                        '-c:v', 'libx264',
                        '-preset', 'medium',
                        '-crf', '23',
                        '-c:a', 'aac',
                        '-b:a', '128k',
                        'output.mp4'
                    ]);

                    const data = await ffmpeg.readFile('output.mp4');
                    const blob = new Blob([data.buffer], { type: 'video/mp4' });

                    await ffmpeg.deleteFile('input.webm');
                    await ffmpeg.deleteFile('output.mp4');

                    return blob;
                } catch (error) {
                    console.error('FFmpeg error:', error);
                    throw new Error('FFmpeg conversion failed: ' + error.message);
                }
            }

            async performConversion() {
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';

                if (this.currentFile) {
                    video.src = URL.createObjectURL(this.currentFile);
                } else {
                    video.src = this.currentUrl;
                }

                video.muted = false;

                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Timeout loading video'));
                    }, 15000);

                    video.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    video.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('Failed to load video'));
                    };
                });

                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth % 2 === 0 ? video.videoWidth : video.videoWidth + 1;
                canvas.height = video.videoHeight % 2 === 0 ? video.videoHeight : video.videoHeight + 1;
                const ctx = canvas.getContext('2d');

                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const audioDestination = audioCtx.createMediaStreamDestination();

                try {
                    const source = audioCtx.createMediaElementSource(video);
                    source.connect(audioDestination);
                    source.connect(audioCtx.destination);
                } catch (e) {
                    console.warn('No audio track:', e.message);
                }

                const stream = canvas.captureStream(30);
                const audioTracks = audioDestination.stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    stream.addTrack(audioTracks[0]);
                }

                let mimeType = 'video/webm;codecs=vp9,opus';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8,opus';
                }
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm';
                }

                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000,
                    audioBitsPerSecond: 128000
                });

                const chunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };

                mediaRecorder.start(100);

                await new Promise((resolve) => {
                    let animationId;

                    const drawFrame = () => {
                        if (!video.paused && !video.ended) {
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                            const progress = (video.currentTime / video.duration) * 100;
                            this.showProgress(Math.min(95, progress));

                            animationId = requestAnimationFrame(drawFrame);
                        }
                    };

                    video.onended = () => {
                        cancelAnimationFrame(animationId);
                        video.pause();
                        resolve();
                    };

                    video.onerror = (e) => {
                        cancelAnimationFrame(animationId);
                        console.error('Video playback error:', e);
                        resolve();
                    };

                    video.currentTime = 0;
                    video.play().then(() => {
                        drawFrame();
                    }).catch(err => {
                        console.error('Play error:', err);
                        resolve();
                    });
                });

                mediaRecorder.stop();

                const blob = await new Promise((resolve) => {
                    mediaRecorder.onstop = () => {
                        resolve(new Blob(chunks, { type: mimeType }));
                    };

                    setTimeout(() => {
                        if (chunks.length > 0) {
                            resolve(new Blob(chunks, { type: mimeType }));
                        }
                    }, 1000);
                });

                if (this.currentFile) {
                    URL.revokeObjectURL(video.src);
                }
                video.src = '';
                audioCtx.close();

                return blob;
            }

            clear() {
                this.currentFile = null;
                this.currentUrl = null;
                document.getElementById('convertVideoInfo').style.display = 'none';
                document.getElementById('convertPreviewVideo').style.display = 'none';
                document.getElementById('convertVideoUrlInput').value = '';
                document.getElementById('convertFileInput').value = '';
                this.updateConvertButton();
                this.hideStatus();
            }

            showProgress(percent) {
                const progressContainer = document.getElementById('convertProgressContainer');
                const progressFill = document.getElementById('convertProgressFill');
                progressContainer.style.display = 'block';
                progressFill.style.width = percent + '%';
                progressFill.textContent = Math.round(percent) + '%';
            }

            hideProgress() {
                document.getElementById('convertProgressContainer').style.display = 'none';
            }

            showStatus(message, type) {
                const status = document.getElementById('convertStatus');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            hideStatus() {
                const status = document.getElementById('convertStatus');
                status.className = 'status';
            }
        }

        // Initialize both
        const videoConcatenator = new VideoConcatenator();
        const videoConverter = new VideoConverter();
    </script>
</body>
</html>
