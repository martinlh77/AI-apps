<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Luxury 3D Mancala - Boutique Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #ui { position: absolute; top: 15px; left: 15px; right: 15px; color: white; pointer-events: none; z-index: 10; display: flex; justify-content: space-between; }
        .panel { background: rgba(0,0,0,0.85); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); pointer-events: auto; backdrop-filter: blur(8px); box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        .controls { display: flex; flex-direction: column; gap: 10px; min-width: 180px; }
        button, select { 
            padding: 10px; background: #222; color: white; border: 1px solid #444; border-radius: 6px; cursor: pointer; font-size: 13px; transition: all 0.2s;
        }
        button:hover { background: #444; border-color: #666; }
        #msg { font-size: 28px; font-weight: bold; color: #f1c40f; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); margin-bottom: 5px; }
        #score { font-size: 18px; color: #aaa; margin-bottom: 15px; letter-spacing: 1px; }
        label { font-size: 10px; text-transform: uppercase; color: #777; margin-bottom: 2px; display: block; font-weight: bold; }
        #loading { position: fixed; inset: 0; background: #000; color: white; display: flex; align-items: center; justify-content: center; z-index: 100; font-size: 20px; }
    </style>
</head>
<body>

<div id="loading">Polishing the Wood...</div>

<div id="ui">
    <div>
        <div id="msg">Player 1's Turn</div>
        <div id="score">P1: 0 | P2: 0</div>
        <div class="panel">
            <button onclick="resetGame()">Reset Game</button>
            <button onclick="toggleAI()" id="aiBtn">Mode: PvP</button>
        </div>
    </div>

    <div class="panel controls">
        <div>
            <label>Board Material</label>
            <select id="boardStyle" onchange="updateVisuals()">
                <option value="ebony">Midnight Ebony</option>
                <option value="mahogany">Royal Mahogany</option>
                <option value="walnut">Dark Walnut</option>
                <option value="oak">Golden Oak</option>
                <option value="cherry">Polished Cherry</option>
            </select>
        </div>
        <div>
            <label>Bead Style</label>
            <select id="beadStyle" onchange="updateVisuals()">
                <option value="glass">Stained Glass</option>
                <option value="crystal">Pure Crystal</option>
                <option value="gem">Faceted Gems</option>
                <option value="duck">Tiny Ducks</option>
                <option value="pearl">Matte Pearl</option>
            </select>
        </div>
        <div>
            <label>Environment</label>
            <select id="bgStyle" onchange="updateVisuals()">
                <option value="studio">Photo Studio</option>
                <option value="warm">Tavern Hearth</option>
                <option value="night">Moonlight</option>
            </select>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

<script>
const CONFIG = {
    pitRadius: 0.65,
    storeRadius: 0.85,
    boardWidth: 13.5,
    boardHeight: 5.5,
    beadSize: 0.14,
    bowlDepth: 0.35
};

let scene, camera, renderer, controls, raycaster;
let boardGroup, boardMaterial;
let boardState = Array.from({ length: 14 }, () => []);
let pitPositions = [];
let currentPlayer = 0, isTurnInProgress = false, isAIMode = false;
const mouse = new THREE.Vector2();

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 11, 11);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2.1;

    raycaster = new THREE.Raycaster();

    const amb = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(amb);
    
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(10, 20, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    updateVisuals();
    resetGame();
    
    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    
    document.getElementById('loading').style.display = 'none';
    animate();
}

function createWoodTexture(color) {
    const canvas = document.createElement('canvas');
    canvas.width = 1024; canvas.height = 1024;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 1024, 1024);
    for(let i=0; i<2000; i++) {
        // Reduced grain visibility for darker woods to keep them looking "expensive"
        ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.12)';
        ctx.fillRect(Math.random() * 1024, 0, Math.random() * 2 + 1, 1024);
    }
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2, 1);
    return tex;
}

function createBoard() {
    if (boardGroup) scene.remove(boardGroup);
    boardGroup = new THREE.Group();
    const style = document.getElementById('boardStyle').value;
    
    // Updated wood color library
    const woodColors = { 
        walnut: '#2c1e14', 
        oak: '#a67c49', 
        cherry: '#631a0d',
        mahogany: '#3d0c02', // Dark reddish-brown
        ebony: '#080808'      // Deep midnight black
    };
    
    boardMaterial = new THREE.MeshStandardMaterial({ 
        map: createWoodTexture(woodColors[style]),
        roughness: style === 'ebony' ? 0.2 : 0.4, // Ebony is typically polished higher
        metalness: style === 'ebony' ? 0.2 : 0.1,
        side: THREE.DoubleSide
    });

    const shape = new THREE.Shape();
    const w = CONFIG.boardWidth / 2, h = CONFIG.boardHeight / 2;
    shape.moveTo(-w, -h); shape.lineTo(w, -h); shape.lineTo(w, h); shape.lineTo(-w, h);

    const addHole = (x, y, r) => {
        const path = new THREE.Path();
        path.absarc(x, y, r, 0, Math.PI * 2, true);
        shape.holes.push(path);
    };

    pitPositions = [];
    for(let i=0; i<6; i++) {
        let x = -3.75 + (i * 1.5), z = 1.2;
        addHole(x, z, CONFIG.pitRadius);
        pitPositions[i] = new THREE.Vector3(x, 0, z);
    }
    addHole(5.4, 0, CONFIG.storeRadius);
    pitPositions[6] = new THREE.Vector3(5.4, 0, 0);
    for(let i=0; i<6; i++) {
        let x = 3.75 - (i * 1.5), z = -1.2;
        addHole(x, z, CONFIG.pitRadius);
        pitPositions[7+i] = new THREE.Vector3(x, 0, z);
    }
    addHole(-5.4, 0, CONFIG.storeRadius);
    pitPositions[13] = new THREE.Vector3(-5.4, 0, 0);

    const extrudeSettings = { depth: 0.45, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1 };
    const slabGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    slabGeo.rotateX(Math.PI/2);
    const slab = new THREE.Mesh(slabGeo, boardMaterial);
    slab.position.y = 0.5;
    slab.receiveShadow = true;
    boardGroup.add(slab);

    pitPositions.forEach((pos, idx) => {
        const r = (idx === 6 || idx === 13) ? CONFIG.storeRadius : CONFIG.pitRadius;
        const bowlGeo = new THREE.SphereGeometry(r, 24, 16, 0, Math.PI * 2, Math.PI/2, Math.PI/2);
        const bowl = new THREE.Mesh(bowlGeo, boardMaterial);
        bowl.position.set(pos.x, 0.51, pos.z);
        bowl.receiveShadow = true;
        bowl.userData = { index: idx };
        boardGroup.add(bowl);
    });
    scene.add(boardGroup);
}

function createBeadMesh() {
    const style = document.getElementById('beadStyle').value;
    const h = Math.random();
    // Slightly darker base lightness for stained glass (0.35 instead of 0.5)
    const color = new THREE.Color().setHSL(h, 0.8, 0.35);
    let mesh;

    if (style === 'glass') {
        // Stained Glass: Darker, richer hues
        mesh = new THREE.Mesh(
            new THREE.SphereGeometry(CONFIG.beadSize, 16, 12),
            new THREE.MeshPhysicalMaterial({ 
                color: color, 
                transmission: 0.5, // Reduced transmission for "slightly darker" look
                thickness: 0.5, 
                roughness: 0.1, 
                metalness: 0.1,
                clearcoat: 1.0,
                transparent: true,
                opacity: 0.95
            })
        );
    } else if (style === 'crystal') {
        // Pure Crystal: Changed from pure white to a light grey for "Smoky Crystal" effect
        mesh = new THREE.Mesh(
            new THREE.SphereGeometry(CONFIG.beadSize, 24, 24),
            new THREE.MeshPhysicalMaterial({ 
                color: 0x999999, // Grayish tint makes it look darker/smoky
                transmission: 0.9, 
                thickness: 1.5, 
                roughness: 0.0, 
                ior: 2.4, 
                metalness: 0.2, 
                transparent: true,
                opacity: 0.8
            })
        );
    } else if (style === 'gem') {
        mesh = new THREE.Mesh(
            new THREE.IcosahedronGeometry(CONFIG.beadSize, 1),
            new THREE.MeshPhongMaterial({ color, shininess: 100, flatShading: true })
        );
    } else if (style === 'duck') {
        const duck = new THREE.Group();
        const yellow = new THREE.MeshStandardMaterial({color: 0xffd700, roughness: 0.4});
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), yellow);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.09, 12, 12), yellow);
        head.position.set(0.08, 0.1, 0);
        const beak = new THREE.Mesh(new THREE.ConeGeometry(0.035, 0.08, 8), new THREE.MeshStandardMaterial({color: 0xff4500}));
        beak.rotation.z = -Math.PI / 2; beak.position.set(0.16, 0.1, 0);
        const eyeMat = new THREE.MeshStandardMaterial({color: 0x000000});
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), eyeMat);
        eyeL.position.set(0.13, 0.14, 0.04);
        const eyeR = eyeL.clone(); eyeR.position.z = -0.04;
        duck.add(body, head, beak, eyeL, eyeR);
        return duck;
    } else {
        mesh = new THREE.Mesh(
            new THREE.SphereGeometry(CONFIG.beadSize, 16, 12),
            new THREE.MeshStandardMaterial({ color, roughness: 0.9 })
        );
    }
    mesh.castShadow = true;
    return mesh;
}

function getBeadPosition(pitIdx, beadIndexInPit) {
    const pos = pitPositions[pitIdx];
    const isStore = (pitIdx === 6 || pitIdx === 13);
    const beadsPerLayer = isStore ? 8 : 5;
    const layer = Math.floor(beadIndexInPit / beadsPerLayer);
    const angle = (beadIndexInPit % beadsPerLayer) * ((Math.PI * 2) / beadsPerLayer) + (layer * 0.4);
    const dist = beadIndexInPit === 0 ? 0 : Math.min(isStore ? 0.6 : 0.4, 0.15 + (layer * 0.08));
    return new THREE.Vector3(pos.x + Math.cos(angle) * dist, 0.28 + (layer * 0.18), pos.z + Math.sin(angle) * dist);
}

function updateVisuals() {
    const bg = document.getElementById('bgStyle').value;
    const colors = { studio: 0x111111, warm: 0x24140a, night: 0x050510 };
    scene.background = new THREE.Color(colors[bg]);
    createBoard();
    boardState.forEach((pit, pIdx) => {
        pit.forEach((bead, bIdx) => {
            const newBead = createBeadMesh();
            newBead.position.copy(bead.position);
            scene.remove(bead); scene.add(newBead);
            boardState[pIdx][bIdx] = newBead;
        });
    });
}

async function executeMove(startIndex) {
    if (isTurnInProgress || boardState[startIndex].length === 0) return;
    isTurnInProgress = true;
    let hand = [...boardState[startIndex]]; boardState[startIndex] = [];
    await Promise.all(hand.map((b, i) => gsap.to(b.position, { y: 2, duration: 0.3, delay: i * 0.04 })));
    let curr = startIndex;
    while (hand.length > 0) {
        curr = (curr + 1) % 14;
        if (currentPlayer === 0 && curr === 13) curr = 0;
        if (currentPlayer === 1 && curr === 6) curr = 7;
        const bead = hand.pop();
        const targetPos = getBeadPosition(curr, boardState[curr].length);
        await gsap.to(bead.position, { x: targetPos.x, z: targetPos.z, y: 1.8, duration: 0.12 });
        boardState[curr].push(bead);
        gsap.to(bead.position, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 0.4, ease: "bounce.out" });
        await new Promise(r => setTimeout(r, 80));
    }
    const isMySide = currentPlayer === 0 ? (curr <= 5) : (curr >= 7 && curr <= 12);
    if (isMySide && boardState[curr].length === 1 && curr !== 6 && curr !== 13) {
        const opp = 12 - curr;
        if (boardState[opp].length > 0) {
            const storeIdx = currentPlayer === 0 ? 6 : 13;
            const captured = [...boardState[curr], ...boardState[opp]];
            boardState[curr] = []; boardState[opp] = [];
            captured.forEach((b, i) => {
                const target = getBeadPosition(storeIdx, boardState[storeIdx].length);
                boardState[storeIdx].push(b);
                gsap.to(b.position, { x: target.x, z: target.z, y: 1.5, duration: 0.5, delay: i * 0.05, 
                    onComplete: () => { gsap.to(b.position, { y: target.y, duration: 0.3, ease: "bounce.out" }); }
                });
            });
        }
    }
    const gameOver = boardState.slice(0, 6).every(p => p.length === 0) || boardState.slice(7, 13).every(p => p.length === 0);
    if (gameOver) await handleFinalSweep();
    else {
        const extraTurn = (currentPlayer === 0 && curr === 6) || (currentPlayer === 1 && curr === 13);
        if (!extraTurn) currentPlayer = 1 - currentPlayer;
        document.getElementById('msg').innerText = extraTurn ? "Extra Turn!" : `Player ${currentPlayer + 1}'s Turn`;
    }
    updateUI(); isTurnInProgress = false;
    if (!gameOver && currentPlayer === 1 && isAIMode) setTimeout(aiMove, 800);
}

async function handleFinalSweep() {
    document.getElementById('msg').innerText = "Game Over! Sweeping...";
    for (let i = 0; i < 6; i++) if (boardState[i].length > 0) await sweepToStore(i, 6);
    for (let i = 7; i < 13; i++) if (boardState[i].length > 0) await sweepToStore(i, 13);
    const p1 = boardState[6].length, p2 = boardState[13].length;
    document.getElementById('msg').innerText = p1 > p2 ? "Player 1 Wins!" : p1 < p2 ? "Player 2 Wins!" : "Draw!";
}

async function sweepToStore(fromIdx, storeIdx) {
    const beads = [...boardState[fromIdx]]; boardState[fromIdx] = [];
    await Promise.all(beads.map((b, i) => {
        const target = getBeadPosition(storeIdx, boardState[storeIdx].length);
        boardState[storeIdx].push(b);
        return gsap.to(b.position, { x: target.x, y: 1.5, z: target.z, duration: 0.5, onComplete: () => { gsap.to(b.position, { y: target.y, duration: 0.3 }); }});
    }));
}

function resetGame() {
    boardState.forEach(p => p.forEach(b => scene.remove(b)));
    boardState = Array.from({ length: 14 }, () => []);
    for (let i = 0; i < 14; i++) {
        if (i === 6 || i === 13) continue;
        for (let j = 0; j < 4; j++) {
            const bead = createBeadMesh();
            bead.position.copy(getBeadPosition(i, j));
            scene.add(bead); boardState[i].push(bead);
        }
    }
    currentPlayer = 0; isTurnInProgress = false; updateUI();
}

function updateUI() { document.getElementById('score').innerText = `P1: ${boardState[6].length} | P2: ${boardState[13].length}`; }
function toggleAI() { isAIMode = !isAIMode; document.getElementById('aiBtn').innerText = isAIMode ? "Mode: vs CPU" : "Mode: PvP"; resetGame(); }
function aiMove() {
    const validMoves = [];
    for (let i = 7; i <= 12; i++) if (boardState[i].length > 0) validMoves.push(i);
    if (validMoves.length > 0) executeMove(validMoves[Math.floor(Math.random() * validMoves.length)]);
}

let startCoords = { x: 0, y: 0 };
function onPointerDown(e) { startCoords = { x: e.clientX, y: e.clientY }; }
function onPointerUp(e) {
    if (Math.hypot(e.clientX - startCoords.x, e.clientY - startCoords.y) > 10) return;
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(boardGroup.children);
    if (hits.length > 0) {
        let clickedIdx = -1;
        for(let hit of hits) if(hit.object.userData.index !== undefined) { clickedIdx = hit.object.userData.index; break; }
        if (clickedIdx !== -1) {
            if (currentPlayer === 0 && clickedIdx <= 5) executeMove(clickedIdx);
            else if (!isAIMode && currentPlayer === 1 && clickedIdx >= 7 && clickedIdx <= 12) executeMove(clickedIdx);
        }
    }
}

function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
init();
</script>
</body>
</html>
