<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Mancala Mobile</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #1a1a1a; 
            font-family: sans-serif;
            touch-action: none; 
        }
        #ui {
            position: absolute; top: 10px; left: 10px; right: 10px;
            color: white; pointer-events: none; z-index: 10;
        }
        .controls { pointer-events: auto; display: flex; gap: 10px; margin-top: 5px; }
        button { 
            padding: 12px; background: #444; color: white; 
            border: 1px solid #666; border-radius: 8px; font-size: 14px;
        }
        #msg { font-size: 22px; font-weight: bold; color: #f1c40f; text-shadow: 2px 2px 2px black; }
        #score { font-size: 16px; margin-top: 4px; }
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a; color: white; display: flex;
            align-items: center; justify-content: center; z-index: 100;
        }
    </style>
</head>
<body>

<div id="loading-overlay">Loading 3D Board...</div>

<div id="ui">
    <div id="msg">Player 1's Turn</div>
    <div id="score">P1: 0 | P2: 0</div>
    <div class="controls">
        <button onclick="resetGame()">Reset</button>
        <button onclick="toggleAI()" id="aiBtn">Mode: PvP</button>
    </div>
</div>

<!-- Use specific versions to ensure compatibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Using a version of OrbitControls compatible with the global THREE object -->
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

<script>
/**
 * ERROR HANDLING FOR MOBILE
 */
window.onerror = function(msg, url, line) {
    alert("Error: " + msg + "\nLine: " + line);
};

/** 
 * GAME CONFIG 
 */
const CONFIG = {
    pitCount: 6,
    initialSeeds: 4,
    pitRadius: 0.8,
    beadSize: 0.14,
    colors: { board: 0x8B4513 }
};

let boardState = Array.from({ length: 14 }, () => []);
let isTurnInProgress = false;
let currentPlayer = 0; 
let isAIMode = false;
let scene, camera, renderer, controls, raycaster;
const mouse = new THREE.Vector2();
const pitPositions = [];

function init() {
    try {
        // SCENE & RENDERER
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 12); 

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // CONTROLS
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.minDistance = 5;
        controls.maxDistance = 25;

        // LIGHTS
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 0.5);
        sun.position.set(5, 15, 5);
        sun.castShadow = true;
        scene.add(sun);

        raycaster = new THREE.Raycaster();

        createBoard();
        resetGame();
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        animate();

        // Remove loading screen
        document.getElementById('loading-overlay').style.display = 'none';
    } catch (e) {
        alert("Fatal Init Error: " + e);
    }
}

function createBoard() {
    const boardGeo = new THREE.BoxGeometry(12, 0.5, 4.5);
    const boardMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.board });
    const board = new THREE.Mesh(boardGeo, boardMat);
    board.receiveShadow = true;
    scene.add(board);

    const pitMat = new THREE.MeshStandardMaterial({ color: 0x331a07 });

    const addPit = (x, z, idx, isStore = false) => {
        const radius = isStore ? 0.9 : CONFIG.pitRadius;
        const geo = new THREE.CylinderGeometry(radius, radius * 0.8, 0.2, 24);
        const pit = new THREE.Mesh(geo, pitMat);
        pit.position.set(x, 0.26, z);
        pit.userData = { index: idx };
        scene.add(pit);
        pitPositions[idx] = new THREE.Vector3(x, 0.3, z);
    };

    for (let i = 0; i < 6; i++) addPit(-3.75 + i * 1.5, 1.2, i);
    addPit(5.3, 0, 6, true);
    for (let i = 0; i < 6; i++) addPit(3.75 - i * 1.5, -1.2, 7 + i);
    addPit(-5.3, 0, 13, true);
}

function createBead(pitIdx) {
    const geo = new THREE.SphereGeometry(CONFIG.beadSize, 8, 8);
    const mat = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color().setHSL(Math.random(), 0.8, 0.5) 
    });
    const bead = new THREE.Mesh(geo, mat);
    bead.castShadow = true;
    placeBeadInPit(bead, pitIdx);
    scene.add(bead);
    return bead;
}

function placeBeadInPit(bead, pitIdx) {
    const pos = pitPositions[pitIdx];
    const dist = Math.random() * (pitIdx === 6 || pitIdx === 13 ? 0.6 : 0.4);
    const angle = Math.random() * Math.PI * 2;
    bead.position.set(
        pos.x + Math.cos(angle) * dist,
        pos.y + (Math.random() * 0.1),
        pos.z + Math.sin(angle) * dist
    );
}

async function executeMove(startIndex) {
    if (isTurnInProgress) return;
    let hand = boardState[startIndex];
    if (!hand || hand.length === 0) return;

    isTurnInProgress = true;
    boardState[startIndex] = [];

    // Visual Lift
    const liftTl = gsap.timeline();
    hand.forEach(bead => {
        liftTl.to(bead.position, { y: 2.5, duration: 0.3 }, 0);
    });
    await liftTl;

    let currentIndex = startIndex;
    const count = hand.length;

    for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1) % 14;
        if (currentPlayer === 0 && currentIndex === 13) currentIndex = 0;
        if (currentPlayer === 1 && currentIndex === 6) currentIndex = 7;

        const bead = hand.pop();
        const target = pitPositions[currentIndex];

        await gsap.to(bead.position, { x: target.x, z: target.z, y: 2.5, duration: 0.15 });
        
        boardState[currentIndex].push(bead);
        const dist = Math.random() * 0.4;
        const ang = Math.random() * Math.PI * 2;
        
        gsap.to(bead.position, { 
            y: target.y + (boardState[currentIndex].length * 0.03),
            x: target.x + Math.cos(ang) * dist,
            z: target.z + Math.sin(ang) * dist,
            duration: 0.3, ease: "bounce.out" 
        });
    }

    await new Promise(r => setTimeout(r, 400));

    // Capture Logic
    const isMySide = currentPlayer === 0 ? (currentIndex <= 5) : (currentIndex >= 7 && currentIndex <= 12);
    if (isMySide && boardState[currentIndex].length === 1 && currentIndex !== 6 && currentIndex !== 13) {
        const opp = 12 - currentIndex;
        if (boardState[opp].length > 0) {
            const storeIdx = currentPlayer === 0 ? 6 : 13;
            const captured = [...boardState[currentIndex], ...boardState[opp]];
            boardState[currentIndex] = []; boardState[opp] = [];
            captured.forEach(b => {
                gsap.to(b.position, { x: pitPositions[storeIdx].x, z: pitPositions[storeIdx].z, y: 1.5, duration: 0.5, onComplete: () => {
                    placeBeadInPit(b, storeIdx);
                    boardState[storeIdx].push(b);
                    updateUI();
                }});
            });
        }
    }

    const landedInStore = (currentPlayer === 0 && currentIndex === 6) || (currentPlayer === 1 && currentIndex === 13);
    
    if (checkGameOver()) {
        endGame();
    } else if (!landedInStore) {
        currentPlayer = 1 - currentPlayer;
        document.getElementById('msg').innerText = `Player ${currentPlayer + 1}'s Turn`;
    } else {
        document.getElementById('msg').innerText = "Extra Turn!";
    }

    updateUI();
    isTurnInProgress = false;
    if (currentPlayer === 1 && isAIMode) setTimeout(aiMove, 1000);
}

function aiMove() {
    const moves = [];
    for (let i = 7; i <= 12; i++) if (boardState[i].length > 0) moves.push(i);
    if (moves.length > 0) executeMove(moves[Math.floor(Math.random() * moves.length)]);
}

function checkGameOver() {
    return boardState.slice(0, 6).every(p => p.length === 0) || boardState.slice(7, 13).every(p => p.length === 0);
}

function updateUI() {
    document.getElementById('score').innerText = `P1: ${boardState[6].length} | P2: ${boardState[13].length}`;
}

function resetGame() {
    boardState.forEach(p => p.forEach(b => scene.remove(b)));
    boardState = Array.from({ length: 14 }, () => []);
    for (let i = 0; i < 14; i++) {
        if (i === 6 || i === 13) continue;
        for (let j = 0; j < CONFIG.initialSeeds; j++) boardState[i].push(createBead(i));
    }
    currentPlayer = 0;
    isTurnInProgress = false;
    document.getElementById('msg').innerText = "Player 1's Turn";
    updateUI();
}

function toggleAI() {
    isAIMode = !isAIMode;
    document.getElementById('aiBtn').innerText = isAIMode ? "vs CPU" : "PvP";
    resetGame();
}

function endGame() {
    const p1 = boardState[6].length, p2 = boardState[13].length;
    document.getElementById('msg').innerText = p1 > p2 ? "P1 Wins!" : p1 < p2 ? "P2 Wins!" : "Tie!";
}

// REFINED INPUT HANDLING (WORKS FOR BOTH MOBILE & DESKTOP)
let startPoint = { x: 0, y: 0 };
let startTime = 0;

function onPointerDown(e) {
    startPoint.x = e.clientX;
    startPoint.y = e.clientY;
    startTime = Date.now();
}

function onPointerUp(e) {
    const duration = Date.now() - startTime;
    const dist = Math.hypot(e.clientX - startPoint.x, e.clientY - startPoint.y);

    // If held longer than 300ms OR moved more than 5px, treat as camera drag, not click
    if (duration > 300 || dist > 5) return;

    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(scene.children, true);

    for (let h of hits) {
        let idx = h.object.userData.index;

        // Desktop Fix: If player clicks a bead directly, find which pit it belongs to
        if (idx === undefined && h.object.geometry && h.object.geometry.type === "SphereGeometry") {
            for (let i = 0; i < 14; i++) {
                if (boardState[i].includes(h.object)) {
                    idx = i;
                    break;
                }
            }
        }

        if (idx !== undefined) {
            if (currentPlayer === 0 && idx <= 5) {
                executeMove(idx);
                break;
            } else if (!isAIMode && currentPlayer === 1 && idx >= 7 && idx <= 12) {
                executeMove(idx);
                break;
            }
        }
    }
}

function animate() {
    requestAnimationFrame(animate);
    if (controls) controls.update();
    if (renderer && scene && camera) renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// START
init();
</script>
</body>
</html>
