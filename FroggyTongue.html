<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Froggy's Flying Food Fiasco! üê∏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 100%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 70%, #90EE90 100%);
        }

        #scoreBoard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 15px;
            border: 3px solid #2d5016;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            z-index: 10;
        }

        #score {
            font-size: 28px;
            font-weight: bold;
            color: #2d5016;
            text-shadow: 2px 2px 0px #90EE90;
        }

        #round {
            font-size: 20px;
            color: #2d5016;
            margin-top: 5px;
        }

        #timer {
            font-size: 24px;
            color: #FF4500;
            margin-top: 5px;
            font-weight: bold;
        }

        #roundTransition {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px 60px;
            border-radius: 20px;
            border: 5px solid #2d5016;
            text-align: center;
            display: none;
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
            z-index: 100;
        }

        #roundTransition h1 {
            color: #2d5016;
            margin-bottom: 20px;
            font-size: 48px;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #roundTransition p {
            font-size: 24px;
            margin: 10px 0;
            color: #FF4500;
        }

        .pun {
            font-style: italic;
            color: #2d5016;
            font-size: 18px;
            margin-top: 15px;
        }

        button {
            background: #90EE90;
            border: 3px solid #2d5016;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-family: 'Comic Sans MS', cursive;
            transition: all 0.2s;
        }

        button:hover {
            background: #7CFC00;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="scoreBoard">
        <div id="score">Score: 0 ü™∞</div>
        <div id="round">Round: 1</div>
        <div id="timer">Time: 60s</div>
    </div>
    <div id="roundTransition">
        <h1 id="transitionTitle">Round 2!</h1>
        <p id="transitionMessage">Things are getting BUG-NANAS! üçåü™∞</p>
        <p class="pun" id="transitionPun">Hope you're not feeling too fly-gued!</p>
        <button onclick="startNextRound()">Hop To It!</button>
    </div>

    <script>
        // Set up canvas - because every frog needs a stage for their tongue acrobatics!
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state - keeping track of our amphibian's appetite
        let score = 0;
        let currentRound = 1;
        let gameActive = true;
        let tongueActive = false;
        let tongueX = 0;
        let tongueY = 0;
        let tongueProgress = 0;
        let tongueSpeed = 0.15;
        let roundTimer = 60;
        let timerInterval = null;
        let spawnInterval = null;
        let speedMultiplier = 1;

        // Frog object - the star of our show (no autographs, please)
        const frog = {
            x: canvas.width / 2,
            y: canvas.height - 80,
            width: 70,
            height: 50,
            speed: 3,
            direction: 1,
            mouthOpen: false
        };

        // Bug types - it's like a buffet, but everything's flying!
        const bugTypes = {
            fly: { points: 10, speed: 2, size: 15, color: '#000000', emoji: 'ü™∞' },
            bee: { points: 25, speed: 3, size: 18, color: '#FFD700', emoji: 'üêù' },
            beetle: { points: 50, speed: 1.5, size: 20, color: '#8B4513', emoji: 'ü™≤' },
            dragonfly: { points: 100, speed: 4, size: 25, color: '#00CED1', emoji: 'ü¶ü' }
        };

        // Bug army - they don't stand a chance against our tongue-fu master!
        let bugs = [];

        // Hilarious puns for round transitions - because I'm a comedy genius (and modest too!)
        const roundPuns = [
            "Hope you're not feeling too fly-gued!",
            "Time to really BEETLE the odds!",
            "Don't worry, bee happy! ...wait, DO worry!",
            "This is un-BEE-lievable!",
            "You're really on a roll... or should I say, a lily pad!",
            "Hop you can handle this!",
            "Things are about to get toad-ally crazy!",
            "You're killing it! Unlike those bugs you're eating...",
            "Ribbit or leave it, here comes another round!",
            "I'd make a joke about flies, but it might not land well!"
        ];

        // Spawn bugs - like a bug factory, but less creepy and MORE INTENSE
        function spawnBug() {
            if (!gameActive) return;
            
            const types = Object.keys(bugTypes);
            const type = types[Math.floor(Math.random() * types.length)];
            const bugData = bugTypes[type];
            
            bugs.push({
                x: Math.random() * canvas.width,
                y: Math.random() * (canvas.height - 150),
                vx: (Math.random() - 0.5) * bugData.speed * speedMultiplier,
                vy: (Math.random() - 0.5) * bugData.speed * speedMultiplier,
                type: type,
                size: bugData.size,
                rotation: Math.random() * Math.PI * 2
            });
        }

        // Initial bug population - TRIPLE the chaos!
        function initializeRound() {
            bugs = [];
            const initialBugCount = 25; // Way more bugs than before!
            for (let i = 0; i < initialBugCount; i++) {
                spawnBug();
            }
        }

        // Start spawning bugs at a frantic pace - it's raining bugs, hallelujah!
        function startBugSpawning() {
            if (spawnInterval) clearInterval(spawnInterval);
            
            // Spawn faster as rounds progress - because why not make it EXTRA spicy?
            const spawnRate = Math.max(300, 800 - (currentRound * 50));
            
            spawnInterval = setInterval(() => {
                if (gameActive && bugs.length < 50 + (currentRound * 5)) {
                    spawnBug();
                }
            }, spawnRate);
        }

        // Round timer - tick tock, better catch those bugs!
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            roundTimer = 60;
            
            timerInterval = setInterval(() => {
                if (!gameActive) return;
                
                roundTimer--;
                document.getElementById('timer').textContent = `Time: ${roundTimer}s`;
                
                if (roundTimer <= 0) {
                    endRound();
                }
            }, 1000);
        }

        // End round and show transition - intermission for our amphibious athlete!
        function endRound() {
            gameActive = false;
            clearInterval(timerInterval);
            clearInterval(spawnInterval);
            
            currentRound++;
            speedMultiplier += 0.3; // Bugs get 30% faster each round - they've been hitting the gym!
            
            const transitionDiv = document.getElementById('roundTransition');
            document.getElementById('transitionTitle').textContent = `Round ${currentRound}!`;
            document.getElementById('transitionMessage').textContent = 
                `Speed Multiplier: ${speedMultiplier.toFixed(1)}x üöÄ`;
            document.getElementById('transitionPun').textContent = 
                roundPuns[Math.min(currentRound - 2, roundPuns.length - 1)];
            
            transitionDiv.style.display = 'block';
        }

        // Start next round - back to the grind!
        function startNextRound() {
            document.getElementById('roundTransition').style.display = 'none';
            document.getElementById('round').textContent = `Round: ${currentRound}`;
            gameActive = true;
            
            initializeRound();
            startBugSpawning();
            startTimer();
        }

        // Draw frog - our handsome green friend (he does his own stunts!)
        function drawFrog() {
            ctx.save();
            
            // Frog body - it ain't easy being green, but it sure is stylish
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(frog.x - frog.width/2, frog.y - 5, frog.width, 10);
            
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(frog.x, frog.y, frog.width/2, frog.height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes - the better to see you with, my fly!
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(frog.x - 15, frog.y - 20, 12, 0, Math.PI * 2);
            ctx.arc(frog.x + 15, frog.y - 20, 12, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(frog.x - 15, frog.y - 20, 6, 0, Math.PI * 2);
            ctx.arc(frog.x + 15, frog.y - 20, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth - sometimes open for business!
            if (frog.mouthOpen || tongueActive) {
                ctx.fillStyle = '#FF6B6B';
                ctx.beginPath();
                ctx.arc(frog.x, frog.y + 5, 8, 0, Math.PI);
                ctx.fill();
            }
            
            ctx.restore();
        }

        // Draw tongue - the money maker! Or should I say, the honey taker?
        function drawTongue(targetX, targetY, progress) {
            ctx.save();
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            
            const currentX = frog.x + (targetX - frog.x) * progress;
            const currentY = frog.y + (targetY - frog.y) * progress;
            
            ctx.beginPath();
            ctx.moveTo(frog.x, frog.y + 5);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            
            // Tongue tip - the business end!
            ctx.fillStyle = '#FF1493';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        // Draw bugs - the victims of our amphibious appetite
        function drawBugs() {
            bugs.forEach(bug => {
                const bugData = bugTypes[bug.type];
                ctx.save();
                ctx.translate(bug.x, bug.y);
                ctx.rotate(bug.rotation);
                ctx.font = `${bug.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(bugData.emoji, 0, 0);
                ctx.restore();
            });
        }

        // Update bugs - making them fly like they've had too much sugar AND espresso!
        function updateBugs() {
            bugs.forEach(bug => {
                bug.x += bug.vx;
                bug.y += bug.vy;
                bug.rotation += 0.05 * speedMultiplier;
                
                // Bounce off walls - no escape from the frog's domain!
                if (bug.x < 0 || bug.x > canvas.width) bug.vx *= -1;
                if (bug.y < 0 || bug.y > canvas.height - 100) bug.vy *= -1;
                
                // Keep bugs in bounds - like an invisible fence, but for insects
                bug.x = Math.max(0, Math.min(canvas.width, bug.x));
                bug.y = Math.max(0, Math.min(canvas.height - 100, bug.y));
            });
        }

        // Update frog position - our protagonist's dance moves
        function updateFrog() {
            frog.x += frog.speed * frog.direction;
            
            // Bounce at edges - even frogs need boundaries
            if (frog.x > canvas.width - 50 || frog.x < 50) {
                frog.direction *= -1;
            }
        }

        // Handle click/tap - STRIKE LIKE A COBRA! ...wait, wrong reptile
        canvas.addEventListener('click', handleShoot);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            handleShoot({
                clientX: touch.clientX,
                clientY: touch.clientY
            });
        });

        function handleShoot(e) {
                        if (!gameActive || tongueActive) return;
            
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            tongueActive = true;
            tongueX = clickX;
            tongueY = clickY;
            tongueProgress = 0;
            frog.mouthOpen = true;
        }

        // Update tongue animation - like a pink lightning bolt of justice!
        function updateTongue() {
            if (!tongueActive) return;
            
            tongueProgress += tongueSpeed;
            
            // Check for bug collision at tongue tip - GOTCHA!
            if (tongueProgress >= 0.5 && tongueProgress <= 1.0) {
                const currentX = frog.x + (tongueX - frog.x) * tongueProgress;
                const currentY = frog.y + (tongueY - frog.y) * tongueProgress;
                
                bugs = bugs.filter(bug => {
                    const dist = Math.sqrt((bug.x - currentX)**2 + (bug.y - currentY)**2);
                    if (dist < bug.size + 10) {
                        score += bugTypes[bug.type].points;
                        document.getElementById('score').textContent = `Score: ${score} ü™∞`;
                        return false; // Bug goes bye-bye to flavor town!
                    }
                    return true;
                });
            }
            
            // Retract tongue - back to home base
            if (tongueProgress >= 2.0) {
                tongueActive = false;
                tongueProgress = 0;
                frog.mouthOpen = false;
            }
        }

        // Main game loop - where the magic happens (and by magic, I mean tongue physics)
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground - home sweet home for our frog
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            
            if (gameActive) {
                // Update everything
                updateFrog();
                updateBugs();
                updateTongue();
            }
            
            // Draw everything
            drawBugs();
            if (tongueActive) {
                const progress = tongueProgress > 1 ? 2 - tongueProgress : tongueProgress;
                drawTongue(tongueX, tongueY, progress);
            }
            drawFrog();
            
            requestAnimationFrame(gameLoop);
        }

        // Handle window resize - because screens come in all shapes and sizes, unlike frogs
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            frog.y = canvas.height - 80;
        });

        // Initialize the game - LET'S GET HOPPIN'!
        console.log("üê∏ Froggy says: 'Welcome to the NEVER-ENDING bug buffet! I hope you brought your appetite... and your A-game!' üê∏");
        console.log("ü™∞ Each round lasts 60 seconds and the bugs get FASTER! Good luck, you'll need it!");
        console.log("üí° Pro tip: Don't try to eat your actual screen. Trust me on this one.");
        
        initializeRound();
        startBugSpawning();
        startTimer();
        gameLoop();
    </script>
</body>
</html>
