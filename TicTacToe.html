<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Tic-Tac-Toe: The Accountant's Edition</title>
    <style>
        :root {
            --bg: #0f172a;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent-x: #38bdf8;
            --accent-o: #fb7185;
            --text: #f8fafc;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            color: var(--text);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Setup Screen --- */
        #setup-screen {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .setup-card {
            background: var(--glass);
            backdrop-filter: blur(20px);
            padding: 2.5rem;
            border-radius: 32px;
            border: 1px solid var(--glass-border);
            text-align: center;
            width: 90%;
            max-width: 450px;
        }

        .controls-group { margin: 20px 0; display: flex; flex-direction: column; gap: 12px; }

        select, button {
            background: #334155;
            color: white;
            border: 1px solid var(--glass-border);
            padding: 12px;
            border-radius: 12px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover { transform: translateY(-2px); background: #475569; }

        button.primary { 
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            font-weight: bold;
            border: none;
        }

        /* --- Semi-Transparent Win Overlay --- */
        #win-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.7); /* Thinner for board visibility */
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        #win-message {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 1rem;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #win-stats {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
        }

        /* --- Game Layout --- */
        .header {
            padding: 15px;
            background: rgba(15, 23, 42, 0.9);
            border-bottom: 1px solid var(--glass-border);
            text-align: center;
            z-index: 100;
        }

        .scoreboard {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-weight: bold;
        }

        .score-box {
            padding: 5px 15px;
            border-radius: 8px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
        }

        #viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            touch-action: none;
            cursor: grab;
        }

        #zoom-container {
            position: absolute;
            transform-origin: 0 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 100%;
            min-height: 100%;
            pointer-events: none;
        }

        .game-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 100px; /* Extra padding for pan-room */
            justify-content: center;
            pointer-events: auto;
        }

        .ultimate-layout {
            display: grid !important;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .board-wrapper {
            background: var(--glass);
            padding: 15px;
            border-radius: 16px;
            border: 3px solid transparent;
            position: relative;
            transition: all 0.3s;
        }

        .board-wrapper.active-focus {
            border-color: var(--accent-x);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
        }

        .board-wrapper.won-x::after, .board-wrapper.won-o::after {
            content: attr(data-winner);
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 100px;
            background: rgba(15, 23, 42, 0.85);
            border-radius: 12px;
            z-index: 10;
        }
        .board-wrapper.won-x::after { color: var(--accent-x); }
        .board-wrapper.won-o::after { color: var(--accent-o); }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 8px;
        }

        .cell {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            touch-action: manipulation;
        }

        .cell.x { color: var(--accent-x); }
        .cell.o { color: var(--accent-o); }
        .win-pulse { animation: pulse 1s infinite; background: rgba(255,255,255,0.2) !important; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <!-- Setup Screen -->
    <div id="setup-screen">
        <div class="setup-card">
            <h1>TIC-TAC-TOE</h1>
            <div class="controls-group">
                <select id="gameType" onchange="toggleSetupVisibility()">
                    <option value="single">Single Board (Classic)</option>
                    <option value="multi" selected>Sequential Multi-Board</option>
                    <option value="ultimate">Ultimate Tic-Tac-Toe</option>
                </select>

                <div id="multi-options">
                    <label id="rangeLabel">Boards: 3</label>
                    <input type="range" id="boardCount" min="2" max="9" value="3" oninput="document.getElementById('rangeLabel').innerText='Boards: '+this.value">
                </div>

                <select id="playerMode">
                    <option value="pvp">Player vs Player</option>
                    <option value="pve">Player vs Computer</option>
                </select>

                <select id="difficulty">
                    <option value="easy">Easy AI</option>
                    <option value="hard">Impossible AI</option>
                </select>
            </div>
            <button class="primary" onclick="startGame()">START GAME</button>
        </div>
    </div>

    <!-- Win Overlay -->
    <div id="win-overlay">
        <div id="win-message">X WINS!</div>
        <div id="win-stats">Final Score: X-3 | O-2</div>
        <div style="display: flex; gap: 15px;">
            <button class="primary" onclick="restartSameSetup()">Play Again</button>
            <button onclick="document.getElementById('win-overlay').style.display='none'">View Boards</button>
            <button onclick="location.reload()">Main Menu</button>
        </div>
    </div>

    <div class="header hidden" id="gameHeader">
        <div id="statusText" style="font-size: 1.2rem;">X's Turn</div>
        <div class="scoreboard hidden" id="scoreboard">
            <div class="score-box" style="color: var(--accent-x)">X: <span id="x-score">0</span></div>
            <div class="score-box" style="color: var(--accent-o)">O: <span id="o-score">0</span></div>
        </div>
        <button onclick="location.reload()" style="margin-top:10px; padding: 5px 15px; font-size: 0.8rem;">Menu</button>
    </div>

    <div id="viewport" class="hidden">
        <div id="zoom-container">
            <div id="mainGrid" class="game-grid"></div>
        </div>
    </div>

    <script>
        let config = {};
        let state = {
            currentPlayer: 'X',
            currentBoardIdx: 0,
            boards: [],
            mainBoard: Array(9).fill(null),
            activeStatus: [],
            gameActive: true,
            tally: { X: 0, O: 0 }
        };

        const winPatterns = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];

        function toggleSetupVisibility() {
            const type = document.getElementById('gameType').value;
            document.getElementById('multi-options').classList.toggle('hidden', type !== 'multi');
        }

        function startGame() {
            config = {
                type: document.getElementById('gameType').value,
                count: parseInt(document.getElementById('boardCount').value),
                mode: document.getElementById('playerMode').value,
                diff: document.getElementById('difficulty').value
            };

            if (config.type === 'single') config.count = 1;
            if (config.type === 'ultimate') config.count = 9;

            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('gameHeader').classList.remove('hidden');
            document.getElementById('viewport').classList.remove('hidden');
            document.getElementById('scoreboard').classList.toggle('hidden', config.type !== 'multi');

            initGameState();
            renderBoards();
            initPanZoom(); // Enable for all modes for consistency
        }

        function initGameState() {
            state.currentPlayer = 'X';
            state.currentBoardIdx = 0;
            state.boards = Array.from({length: config.count}, () => Array(9).fill(null));
            state.mainBoard = Array(9).fill(null);
            state.activeStatus = Array(config.count).fill(true);
            state.tally = { X: 0, O: 0 };
            state.gameActive = true;
            document.getElementById('win-overlay').style.display = 'none';
            updateScoreUI();
            updateStatus();
        }

        function renderBoards() {
            const grid = document.getElementById('mainGrid');
            grid.innerHTML = '';
            grid.className = 'game-grid' + (config.type === 'ultimate' ? ' ultimate-layout' : '');

            for (let i = 0; i < config.count; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'board-wrapper';
                wrapper.id = `board-${i}`;
                let cellsHTML = '';
                for (let j = 0; j < 9; j++) {
                    cellsHTML += `<div class="cell" data-b="${i}" data-c="${j}"></div>`;
                }
                wrapper.innerHTML = `<div style="font-size:0.6rem; opacity:0.4; margin-bottom:4px">BOARD ${i+1}</div><div class="board">${cellsHTML}</div>`;
                grid.appendChild(wrapper);
            }

            // Attach cell click handlers after rendering
            document.querySelectorAll('.cell').forEach(cell => {
                const bIdx = parseInt(cell.getAttribute('data-b'));
                const cIdx = parseInt(cell.getAttribute('data-c'));
                
                cell.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleCellClick(bIdx, cIdx);
                });
                
                cell.addEventListener('touchend', (e) => {
                    if (!cell.dataset.wasDragging) {
                        e.preventDefault();
                        e.stopPropagation();
                        handleCellClick(bIdx, cIdx);
                    }
                    delete cell.dataset.wasDragging;
                });
            });
        }

        function restartSameSetup() {
            initGameState();
            renderBoards();
        }

        function handleCellClick(bIdx, cIdx) {
            if (!state.gameActive || state.boards[bIdx][cIdx]) return;
            if (config.type === 'multi' && bIdx !== state.currentBoardIdx) return;
            if (config.type === 'ultimate' && state.mainBoard[bIdx]) return;

            executeMove(bIdx, cIdx);
        }

        function executeMove(bIdx, cIdx) {
            state.boards[bIdx][cIdx] = state.currentPlayer;
            const cell = document.querySelector(`[data-b="${bIdx}"][data-c="${cIdx}"]`);
            cell.innerText = state.currentPlayer;
            cell.classList.add('taken', state.currentPlayer.toLowerCase());

            checkSubWin(bIdx);

            if (state.gameActive) {
                if (config.type === 'multi') {
                    advanceSequential();
                } else {
                    state.currentPlayer = state.currentPlayer === 'X' ? 'O' : 'X';
                }
                updateStatus();
                
                if (config.mode === 'pve' && state.currentPlayer === 'O') {
                    setTimeout(aiMove, 400);
                }
            }
        }

        function checkSubWin(bIdx) {
            const b = state.boards[bIdx];
            for (let p of winPatterns) {
                if (b[p[0]] && b[p[0]] === b[p[1]] && b[p[0]] === b[p[2]]) {
                    if (config.type === 'ultimate') {
                        state.mainBoard[bIdx] = state.currentPlayer;
                        const el = document.getElementById(`board-${bIdx}`);
                        el.classList.add(`won-${state.currentPlayer.toLowerCase()}`);
                        el.setAttribute('data-winner', state.currentPlayer);
                        checkUltimateWin();
                    } else if (config.type === 'single') {
                        p.forEach(idx => document.querySelector(`[data-b="${bIdx}"][data-c="${idx}"]`).classList.add('win-pulse'));
                        endGame(`${state.currentPlayer} Wins!`);
                    } else {
                        // Multi mode board win
                        state.tally[state.currentPlayer]++;
                        updateScoreUI();
                        p.forEach(idx => document.querySelector(`[data-b="${bIdx}"][data-c="${idx}"]`).classList.add('win-pulse'));
                        state.activeStatus[bIdx] = false;
                    }
                    return true;
                }
            }
            if (!b.includes(null)) {
                state.activeStatus[bIdx] = false;
                if (config.type === 'single') endGame("It's a Draw!");
            }
            return false;
        }

        function checkUltimateWin() {
            for (let p of winPatterns) {
                if (state.mainBoard[p[0]] && state.mainBoard[p[0]] !== 'TIE' && state.mainBoard[p[0]] === state.mainBoard[p[1]] && state.mainBoard[p[0]] === state.mainBoard[p[2]]) {
                    endGame(`Player ${state.currentPlayer} Wins!`);
                    return;
                }
            }
            if (!state.mainBoard.includes(null)) endGame("Ultimate Tie!");
        }

        function advanceSequential() {
            state.currentBoardIdx++;
            if (state.currentBoardIdx >= config.count) {
                state.currentBoardIdx = 0;
                state.currentPlayer = state.currentPlayer === 'X' ? 'O' : 'X';
            }
            
            if (!state.activeStatus.includes(true)) {
                let winner = "Tie Game!";
                if(state.tally.X > state.tally.O) winner = "Player X Wins the Match!";
                if(state.tally.O > state.tally.X) winner = "Player O Wins the Match!";
                endGame(winner);
                return;
            }

            while (!state.activeStatus[state.currentBoardIdx]) {
                state.currentBoardIdx = (state.currentBoardIdx + 1) % config.count;
                if (state.currentBoardIdx === 0) state.currentPlayer = state.currentPlayer === 'X' ? 'O' : 'X';
            }
        }

        function updateScoreUI() {
            document.getElementById('x-score').innerText = state.tally.X;
            document.getElementById('o-score').innerText = state.tally.O;
        }

        function endGame(msg) {
            state.gameActive = false;
            const overlay = document.getElementById('win-overlay');
            const msgEl = document.getElementById('win-message');
            const statsEl = document.getElementById('win-stats');
            
            msgEl.innerText = msg;
            msgEl.style.color = state.currentPlayer === 'X' ? 'var(--accent-x)' : 'var(--accent-o)';
            
            if(config.type === 'multi') {
                statsEl.innerText = `Final Count: X-${state.tally.X} | O-${state.tally.O}`;
                statsEl.classList.remove('hidden');
            } else {
                statsEl.classList.add('hidden');
            }
            
            overlay.style.display = 'flex';
        }

        function updateStatus() {
            if (!state.gameActive) return;
            const status = document.getElementById('statusText');
            status.innerText = `${state.currentPlayer}'s Turn`;
            status.style.color = state.currentPlayer === 'X' ? 'var(--accent-x)' : 'var(--accent-o)';

            document.querySelectorAll('.board-wrapper').forEach((el, i) => {
                el.classList.remove('active-focus');
                if (config.type === 'multi' && i === state.currentBoardIdx) el.classList.add('active-focus');
            });
        }

        function aiMove() {
            if (!state.gameActive) return;
            let moves = [];
            for (let b = 0; b < config.count; b++) {
                if (config.type === 'multi' && b !== state.currentBoardIdx) continue;
                if (config.type === 'ultimate' && state.mainBoard[b]) continue;
                if (!state.activeStatus[b]) continue;
                for (let c = 0; c < 9; c++) {
                    if (!state.boards[b][c]) moves.push({b, c});
                }
            }
            if (moves.length > 0) {
                const choice = moves[Math.floor(Math.random() * moves.length)];
                executeMove(choice.b, choice.c);
            }
        }

        // --- PAN ZOOM ---
        function initPanZoom() {
            const viewport = document.getElementById('viewport');
            const container = document.getElementById('zoom-container');
            let scale = 0.7, posX = 0, posY = 0, isDragging = false, sx, sy;
            let startX, startY;
            let initialPinchDistance = 0;
            let initialScale = 0.7;
            let pinchCenterX = 0, pinchCenterY = 0;
            let hasMoved = false;

            // Apply initial transform immediately to sync state and visual representation
            container.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;

            function zoomToPoint(newScale, clientX, clientY) {
                // Get the viewport bounds
                const rect = viewport.getBoundingClientRect();
                
                // Calculate point relative to viewport
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                // Calculate the point in container space before zoom
                const pointX = (x - posX) / scale;
                const pointY = (y - posY) / scale;
                
                // Calculate new position to keep the point under cursor
                posX = x - pointX * newScale;
                posY = y - pointY * newScale;
                scale = newScale;
                
                container.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
            }

            // Mouse handling
            viewport.onmousedown = e => { 
                if (e.target.classList.contains('cell')) return;
                isDragging = true; 
                sx = e.clientX - posX; 
                sy = e.clientY - posY; 
            };
            window.onmousemove = e => {
                if (!isDragging) return;
                posX = e.clientX - sx; 
                posY = e.clientY - sy;
                container.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
            };
            window.onmouseup = () => isDragging = false;
            
            viewport.onwheel = e => {
                e.preventDefault();
                const newScale = Math.min(Math.max(0.1, scale + (e.deltaY * -0.001)), 2);
                zoomToPoint(newScale, e.clientX, e.clientY);
            };

            // Touch handling
            viewport.addEventListener('touchstart', e => {
                if (e.target.classList.contains('cell')) return;
                
                if (e.touches.length === 1) {
                    isDragging = true;
                    hasMoved = false;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    sx = e.touches[0].clientX - posX;
                    sy = e.touches[0].clientY - posY;
                } else if (e.touches.length === 2) {
                    e.preventDefault();
                    isDragging = false;
                    
                    // Calculate initial pinch distance
                    initialPinchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    initialScale = scale;
                    
                    // Store the center point of the pinch
                    pinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    pinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                }
            }, { passive: false });

            viewport.addEventListener('touchmove', e => {
                if (e.touches.length === 1 && isDragging) {
                    const moveX = e.touches[0].clientX;
                    const moveY = e.touches[0].clientY;
                    const distance = Math.hypot(moveX - startX, moveY - startY);
                    
                    // Threshold to distinguish between intended tap and drag
                    if (distance > 10) {
                        hasMoved = true;
                        posX = moveX - sx;
                        posY = moveY - sy;
                        container.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                        
                        // Mark all cells as dragging to prevent tap
                        document.querySelectorAll('.cell').forEach(cell => {
                            cell.dataset.wasDragging = 'true';
                        });
                    }
                } else if (e.touches.length === 2) {
                    e.preventDefault();
                    
                    // Calculate current pinch distance
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    // Calculate zoom factor
                    const zoomFactor = currentDistance / initialPinchDistance;
                    const newScale = Math.min(Math.max(0.1, initialScale * zoomFactor), 2);
                    
                    // Zoom towards the pinch center point
                    zoomToPoint(newScale, pinchCenterX, pinchCenterY);
                }
            }, { passive: false });

            viewport.addEventListener('touchend', () => {
                isDragging = false;
                // Clear dragging flags after a short delay
                setTimeout(() => {
                    document.querySelectorAll('.cell').forEach(cell => {
                        delete cell.dataset.wasDragging;
                    });
                }, 50);
            });
        }
    </script>
</body>
</html>
