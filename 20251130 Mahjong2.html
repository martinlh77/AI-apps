<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji Mahjong Solitaire</title>
    <style>
        :root {
            /* Base dimensions - logic relies on these remaining constant 
               Scaling is handled via CSS Transform */
            --tile-w: 46px; 
            --tile-h: 60px;
            --tile-depth: 6px;
            --bg-color: #2e7d32;
            --tile-face: #fffbf0;
            --tile-side: #dcd6c5;
            --tile-border: #999;
            --ui-bg: rgba(0, 0, 0, 0.8);
            --accent: #ffeb3b;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* --- UI Overlay & Menus --- */
        #ui-layer {
            height: 60px;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            z-index: 1000;
            color: white;
            flex-shrink: 0; /* Prevent UI from squishing */
        }

        .stat-box {
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
        }

        .stat-value { color: var(--accent); }

        #controls {
            display: flex;
            gap: 10px;
        }

        button {
            background: #4caf50;
            border: none;
            border-radius: 4px;
            color: white;
            padding: 8px 12px;
            font-size: 13px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }

        button:active { transform: translateY(2px); }
        button.danger { background: #f44336; }
        button.warning { background: #ff9800; color: #000; }
        button.info { background: #2196f3; }
        button:disabled { background: #777; cursor: not-allowed; opacity: 0.7; }

        /* --- Menus --- */
        .modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
        }

        .modal.hidden { display: none; }

        .modal h1 { margin-bottom: 20px; font-size: 2rem; }
        
        .menu-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            text-align: center;
            background: #333;
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        label { display: block; margin-bottom: 5px; color: #aaa; }
        select { padding: 8px; width: 100%; margin-bottom: 10px; font-size: 16px; }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: white;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .checkbox-container input { width: 20px; height: 20px; }

        /* --- Game Board --- */
        #game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        #board {
            position: relative;
            transform-origin: center center;
            /* Width/Height set dynamically by JS based on layout bounds */
            background: rgba(0,0,0,0.05);
            border-radius: 20px;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.2);
        }

        /* --- Tiles --- */
        .tile {
            position: absolute;
            width: var(--tile-w);
            height: var(--tile-h);
            background: var(--tile-face);
            border-radius: 6px;
            box-shadow: 
                2px 3px 0px var(--tile-side), 
                4px 5px 6px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s, filter 0.2s;
            user-select: none;
            box-sizing: border-box;
            border: 1px solid #ccc;
            z-index: 1; /* Base z-index */
        }

        .tile.selected {
            background-color: #e3f2fd;
            transform: translate(-2px, -3px) !important;
            box-shadow: 
                4px 6px 0px var(--tile-side), 
                6px 8px 10px rgba(0,0,0,0.4) !important;
            border: 2px solid #2196f3;
        }

        .tile.hint-glow {
            animation: pulse 1s infinite;
            border: 2px solid #ffeb3b;
            z-index: 1000 !important;
        }

        .tile.blocked {
            filter: brightness(0.75);
            color: rgba(0,0,0,0.5); /* Dim emoji */
            cursor: default;
            box-shadow: 
                1px 1px 0px var(--tile-side), 
                2px 2px 2px rgba(0,0,0,0.2);
        }

        .paused .tile {
            background: #8d6e63 !important;
            color: transparent !important;
            border: 1px solid #5d4037 !important;
            box-shadow: none !important;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 5px yellow; }
            50% { transform: scale(1.1); box-shadow: 0 0 20px yellow; }
            100% { transform: scale(1); box-shadow: 0 0 5px yellow; }
        }

        /* Toast for Auto Solve */
        #toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            z-index: 1500;
            display: none;
            font-weight: bold;
            font-size: 16px;
            pointer-events: none;
        }

        /* --- Mobile Adjustments --- */
        @media (max-width: 600px) {
            #ui-layer { 
                flex-wrap: wrap; 
                height: auto; 
                padding: 10px; 
                gap: 5px;
            }
            .stat-box { 
                font-size: 12px; 
                margin-right: 10px; 
                flex: 1;
                text-align: center;
            }
            #controls { 
                width: 100%; 
                justify-content: center; 
                margin-top: 5px; 
            }
            button { 
                padding: 10px 15px; /* Larger touch targets */
                flex: 1;
            }
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div style="display:flex; width: 100%; justify-content: space-between; max-width: 600px; margin: 0 auto;">
            <div class="stat-box">Score: <span id="score" class="stat-value">0</span></div>
            <div class="stat-box">Time: <span id="timer" class="stat-value">00:00</span></div>
            <div class="stat-box">Pairs: <span id="pairs-left" class="stat-value">0</span></div>
        </div>
        </div>
    
    <div id="mobile-controls-wrapper" style="position: absolute; top: 40px; left:0; width: 100%; display: flex; justify-content: center; z-index: 900; pointer-events: none;">
        <div id="controls" style="pointer-events: auto; padding: 5px; background: rgba(0,0,0,0.3); border-radius: 0 0 10px 10px;">
            <button class="info" onclick="game.hint()">Hint</button>
            <button class="warning" id="pause-btn" onclick="game.togglePause()">Pause</button>
            <button class="info" onclick="game.manualReshuffle()">Shuffle</button>
            <button style="background:purple" onclick="game.startAutoSolve()">Auto</button>
            <button class="danger" onclick="game.quit()">Quit</button>
        </div>
    </div>

    <div id="game-container">
        <div id="board"></div>
        <div id="toast"></div>
    </div>

    <div id="main-menu" class="modal">
        <h1 style="font-size: 3rem;">Emoji Mahjong</h1>
        <div class="menu-group">
            <div>
                <label>Difficulty</label>
                <select id="difficulty">
                    <option value="easy">Easy (36 Tiles)</option>
                    <option value="medium" selected>Medium (72 Tiles)</option>
                    <option value="hard">Hard (108 Tiles)</option>
                    <option value="expert">Expert (144 Tiles)</option>
                </select>
            </div>
            <div>
                <label>Layout</label>
                <select id="layout-select">
                    <option value="turtle">The Turtle (Classic)</option>
                    <option value="pyramid">The Pyramid</option>
                    <option value="walls">City Walls</option>
                    <option value="arena">The Arena</option>
                    <option value="cross">The Cross</option>
                    <option value="butterfly">Butterfly</option>
                </select>
            </div>
            
            <div class="checkbox-container" title="If checked, the board is guaranteed to be solvable without shuffling.">
                <input type="checkbox" id="guaranteed-check">
                <span>Guaranteed Solvable</span>
            </div>

            <button class="info" style="font-size: 1.2rem; padding: 12px;" onclick="game.start()">Start Game</button>
        </div>
    </div>

    <div id="overlay-modal" class="modal hidden">
        <h1 id="overlay-title">Paused</h1>
        <div class="menu-group">
            <p id="overlay-msg" style="font-size: 1.2rem; margin-bottom: 20px;"></p>
            <button class="info" id="overlay-action" style="font-size: 1.1rem; padding: 10px;">Resume</button>
            <button class="danger" onclick="game.quit()" style="font-size: 1.1rem; padding: 10px;">Quit to Menu</button>
        </div>
    </div>

<script>
/**
 * Configuration and Data
 */
const EMOJIS = [
    "ðŸŽ‹", "ðŸŒ¸", "ðŸ®", "ðŸ¯", "ðŸ™", "ðŸ£", "ðŸµ", "ðŸ²", "ðŸŽ", "ðŸŽŒ", 
    "ðŸ‘º", "ðŸ¦Š", "ðŸ¼", "ðŸ¯", "ðŸ¦", "ðŸ®", "ðŸ·", "ðŸ¸", "ðŸ™", "ðŸ¦‹", 
    "ðŸž", "ðŸŒµ", "ðŸŒ´", "ðŸ„", "ðŸ‡", "ðŸ‰", "ðŸŠ", "ðŸ‹", "ðŸŒ", "ðŸ", 
    "ðŸŽ", "ðŸ‘", "ðŸ’", "ðŸ“", "ðŸ¥", "ðŸ…", "ðŸ¥‘", "ðŸ†", "ðŸ¥”", "ðŸ¥•",
    "ðŸŒ½", "ðŸŒ¶ï¸", "ðŸ¥", "ðŸ¥–", "ðŸ§€", "ðŸ¥©", "ðŸ¤", "ðŸ¦", "ðŸ©", "ðŸª"
];

// Constants matching CSS
const TILE_W = 46;
const TILE_H = 60;
const TILE_OFFSET_Z = 6;

// Layout Generators (Returns array of {x, y, z})
const LAYOUTS = {
    turtle: () => {
        let tiles = [];
        for(let x=2; x<=12; x++) for(let y=1; y<=8; y++) tiles.push({x,y,z:0});
        for(let x=4; x<=10; x++) for(let y=2; y<=7; y++) tiles.push({x,y,z:1});
        for(let x=5; x<=9; x++) for(let y=3; y<=6; y++) tiles.push({x,y,z:2});
        for(let x=6; x<=8; x++) for(let y=4; y<=5; y++) tiles.push({x,y,z:3});
        tiles.push({x:7, y:4.5, z:4});
        // Extra wings
        tiles.push({x:0, y:4.5, z:0}, {x:14, y:4.5, z:0}, {x:14, y:1.5, z:0}, {x:14, y:7.5, z:0}, {x:0, y:1.5, z:0}, {x:0, y:7.5, z:0});
        return tiles;
    },
    pyramid: () => {
        let tiles = [];
        for(let z=0; z<6; z++) for(let x=z+2; x<=12-z; x++) for(let y=z+1; y<=9-z; y++) tiles.push({x,y,z});
        return tiles;
    },
    walls: () => {
        let tiles = [];
        for(let z=0; z<4; z++) {
            for(let x=1; x<=4; x++) for(let y=1; y<=3; y++) tiles.push({x,y,z}); 
            for(let x=10; x<=13; x++) for(let y=1; y<=3; y++) tiles.push({x,y,z}); 
            for(let x=1; x<=4; x++) for(let y=6; y<=8; y++) tiles.push({x,y,z}); 
            for(let x=10; x<=13; x++) for(let y=6; y<=8; y++) tiles.push({x,y,z}); 
        }
        for(let x=5; x<=9; x++) tiles.push({x,y:4.5,z:0});
        return tiles;
    },
    arena: () => {
        let tiles = [];
        for(let x=1; x<=13; x++) { tiles.push({x,y:1,z:0}); tiles.push({x,y:8,z:0}); }
        for(let y=2; y<=7; y++) { tiles.push({x:1,y,z:0}); tiles.push({x:13,y,z:0}); }
        for(let z=0; z<3; z++) for(let x=4; x<=10; x++) for(let y=3; y<=6; y++) tiles.push({x,y,z});
        return tiles;
    },
    cross: () => {
        let tiles = [];
        for(let z=0; z<3; z++) for(let x=1; x<=13; x++) for(let y=4; y<=5; y++) tiles.push({x,y,z});
        for(let z=0; z<3; z++) for(let x=6; x<=8; x++) for(let y=1; y<=8; y++) tiles.push({x,y,z});
        tiles.push({x:7, y:4.5, z:3});
        return tiles;
    },
    butterfly: () => {
        let tiles = [];
        for(let z=0; z<3; z++) {
            for(let x=1; x<=5; x++) for(let y=1; y<=8; y++) { if(y!=4&&y!=5) tiles.push({x,y,z}); }
            for(let x=9; x<=13; x++) for(let y=1; y<=8; y++) { if(y!=4&&y!=5) tiles.push({x,y,z}); }
        }
        for(let y=1; y<=8; y++) tiles.push({x:7,y,z:0});
        for(let y=2; y<=7; y++) tiles.push({x:7,y,z:1});
        return tiles;
    }
};

class MahjongGame {
    constructor() {
        this.board = document.getElementById('board');
        this.tiles = []; 
        this.selectedTile = null;
        this.score = 0;
        this.timer = 0;
        this.timerInterval = null;
        this.isPaused = false;
        this.isAutoSolving = false;
        
        // Settings State
        this.settings = {
            difficulty: 'medium',
            layout: 'turtle',
            guaranteed: false
        };
    }

    start() {
        this.settings = {
            difficulty: document.getElementById('difficulty').value,
            layout: document.getElementById('layout-select').value,
            guaranteed: document.getElementById('guaranteed-check').checked
        };
        
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('overlay-modal').classList.add('hidden');

        this.loadLevel();
    }
    
    restart() {
        document.getElementById('overlay-modal').classList.add('hidden');
        this.loadLevel();
    }

    loadLevel() {
        let maxTiles = 144;
        if(this.settings.difficulty === 'easy') maxTiles = 36;
        if(this.settings.difficulty === 'medium') maxTiles = 72;
        if(this.settings.difficulty === 'hard') maxTiles = 108;
        
        let rawLayout = LAYOUTS[this.settings.layout]();
        
        if (rawLayout.length > maxTiles) {
            rawLayout.sort((a,b) => {
                if(a.z !== b.z) return b.z - a.z;
                const distA = Math.abs(a.x - 7) + Math.abs(a.y - 4.5);
                const distB = Math.abs(b.x - 7) + Math.abs(b.y - 4.5);
                return distA - distB;
            });
            rawLayout = rawLayout.slice(0, maxTiles);
        }
        if(rawLayout.length % 2 !== 0) rawLayout.pop();

        this.initBoard(rawLayout, this.settings.guaranteed);
        this.resetStats();
        this.startTimer();
        
        // Initial zoom and listener
        this.adjustZoom();
        window.removeEventListener('resize', this._resizeListener);
        this._resizeListener = () => this.adjustZoom();
        window.addEventListener('resize', this._resizeListener);
    }

    initBoard(layout, guaranteed) {
        this.board.innerHTML = '';
        this.tiles = [];
        this.selectedTile = null;
        this.isAutoSolving = false;
        this.isPaused = false;

        // --- DYNAMIC BOUNDING BOX CALCULATION ---
        // This fixes the "tiny tiles" issue by ensuring the board is only 
        // as big as the specific layout requires.
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        layout.forEach(p => {
            if(p.x < minX) minX = p.x;
            if(p.x > maxX) maxX = p.x;
            if(p.y < minY) minY = p.y;
            if(p.y > maxY) maxY = p.y;
        });

        // Add padding (1 tile width/height buffer)
        const boardWidth = (maxX - minX + 2) * TILE_W;
        const boardHeight = (maxY - minY + 2.5) * TILE_H;
        
        this.board.style.width = `${boardWidth}px`;
        this.board.style.height = `${boardHeight}px`;

        const totalTiles = layout.length;
        const pairsNeeded = totalTiles / 2;
        
        let valuesBase = [];
        for (let i = 0; i < pairsNeeded; i++) {
            let emoji = EMOJIS[i % EMOJIS.length]; 
            if (pairsNeeded > EMOJIS.length) emoji = EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
            valuesBase.push(emoji, emoji);
        }

        let finalValues = [];
        if (guaranteed) {
            let attempts = 0;
            let success = false;
            while(!success && attempts < 500) {
                let testValues = [...valuesBase].sort(() => Math.random() - 0.5);
                if (this.simulateSolvability(layout, testValues)) {
                    finalValues = testValues;
                    success = true;
                }
                attempts++;
            }
            if(!success) console.warn("Could not generate purely solvable board in time. Using random.");
            if(finalValues.length === 0) finalValues = [...valuesBase].sort(() => Math.random() - 0.5);
        } else {
            finalValues = [...valuesBase].sort(() => Math.random() - 0.5);
        }

        layout.forEach((pos, index) => {
            const el = document.createElement('div');
            el.className = 'tile';
            el.dataset.id = index;
            el.textContent = finalValues[index];
            
            // Re-center logic based on bounding box
            // We shift everything so minX becomes 0 + padding
            const normalizedX = pos.x - minX + 0.5; 
            const normalizedY = pos.y - minY + 0.5;

            const left = normalizedX * (TILE_W) + (pos.z * 5); 
            const top = normalizedY * (TILE_H) + (pos.z * -5);
            
            el.style.left = `${left}px`;
            el.style.top = `${top}px`;
            el.style.zIndex = pos.z * 10 + Math.floor(pos.x); 

            el.onclick = (e) => this.handleTileClick(e, index);

            this.board.appendChild(el);

            this.tiles.push({
                id: index,
                el: el,
                x: pos.x,
                y: pos.y,
                z: pos.z,
                val: finalValues[index],
                active: true
            });
        });

        this.checkAvailableMoves(); 
    }

    /**
     * Solvability Check Logic
     */
    simulateSolvability(layout, values) {
        let virtualTiles = layout.map((pos, i) => ({
            id: i, x: pos.x, y: pos.y, z: pos.z, val: values[i], active: true
        }));
        let activeCount = virtualTiles.length;

        const isFree = (t, allTiles) => {
            if (!t.active) return false;
            let blockedLeft = false, blockedRight = false, blockedTop = false;

            for (let other of allTiles) {
                if (!other.active || other.id === t.id) continue;
                const isOverlapping = Math.abs(t.x - other.x) < 0.9 && Math.abs(t.y - other.y) < 0.9;
                if (other.z === t.z + 1 && isOverlapping) blockedTop = true;
                if (other.z === t.z) {
                    const yOverlap = Math.abs(t.y - other.y) < 1.0;
                    if (yOverlap) {
                        if (other.x - t.x > 0.5 && Math.abs(t.x - other.x) < 1.5) blockedRight = true;
                        if (t.x - other.x > 0.5 && Math.abs(t.x - other.x) < 1.5) blockedLeft = true;
                    }
                }
            }
            return !blockedTop && !(blockedLeft && blockedRight);
        };

        while (activeCount > 0) {
            let freeTiles = virtualTiles.filter(t => isFree(t, virtualTiles));
            let matchFound = false;
            for (let i = 0; i < freeTiles.length; i++) {
                for (let j = i + 1; j < freeTiles.length; j++) {
                    if (freeTiles[i].val === freeTiles[j].val) {
                        freeTiles[i].active = false;
                        freeTiles[j].active = false;
                        activeCount -= 2;
                        matchFound = true;
                        break;
                    }
                }
                if(matchFound) break;
            }
            if (!matchFound) return false;
        }
        return true;
    }

    resetStats() {
        this.score = 0;
        this.timer = 0;
        document.getElementById('score').innerText = '0';
        document.getElementById('timer').innerText = '00:00';
    }

    startTimer() {
        clearInterval(this.timerInterval);
        this.timerInterval = setInterval(() => {
            if(!this.isPaused) {
                this.timer++;
                const m = Math.floor(this.timer / 60).toString().padStart(2, '0');
                const s = (this.timer % 60).toString().padStart(2, '0');
                document.getElementById('timer').innerText = `${m}:${s}`;
            }
        }, 1000);
    }

    isTileFree(tile) {
        if (!tile.active) return false;
        let blockedLeft = false, blockedRight = false, blockedTop = false;

        for (let other of this.tiles) {
            if (!other.active || other.id === tile.id) continue;
            
            const xOverlap = Math.abs(tile.x - other.x) < 0.9;
            const yOverlap = Math.abs(tile.y - other.y) < 0.9;

            if (other.z === tile.z + 1 && xOverlap && yOverlap) blockedTop = true;
            if (other.z === tile.z) {
                const yProximate = Math.abs(tile.y - other.y) < 1.0; 
                if (yProximate) {
                    if (tile.x - other.x > 0.5 && Math.abs(tile.x - other.x) < 1.5) blockedLeft = true;
                    if (other.x - tile.x > 0.5 && Math.abs(tile.x - other.x) < 1.5) blockedRight = true;
                }
            }
        }
        return !blockedTop && !(blockedLeft && blockedRight);
    }

    checkAvailableMoves() {
        let activeCount = 0;
        let matches = 0;
        let freeTiles = [];

        this.tiles.forEach(t => {
            if(t.active) {
                activeCount++;
                const isFree = this.isTileFree(t);
                if(isFree) {
                    t.el.classList.remove('blocked');
                    freeTiles.push(t);
                } else {
                    t.el.classList.add('blocked');
                    t.el.classList.remove('selected');
                }
            }
        });

        for(let i=0; i<freeTiles.length; i++) {
            for(let j=i+1; j<freeTiles.length; j++) {
                if(freeTiles[i].val === freeTiles[j].val) matches++;
            }
        }
        
        document.getElementById('pairs-left').innerText = matches;

        if (activeCount === 0) {
            this.gameOver(true);
        } else if (matches === 0 && activeCount > 0) {
            if (!this.isAutoSolving) this.showNoMovesModal();
        }
        
        return freeTiles;
    }

    handleTileClick(e, index) {
        if(this.isPaused || this.isAutoSolving) return;
        const tile = this.tiles[index];
        if (!tile.active || tile.el.classList.contains('blocked')) return;

        if (this.selectedTile && this.selectedTile.id === tile.id) {
            tile.el.classList.remove('selected');
            this.selectedTile = null;
            return;
        }

        if (!this.selectedTile) {
            this.selectedTile = tile;
            tile.el.classList.add('selected');
            return;
        }

        if (this.selectedTile.val === tile.val) {
            this.matchTiles(this.selectedTile, tile);
        } else {
            this.selectedTile.el.classList.remove('selected');
            this.selectedTile = tile;
            tile.el.classList.add('selected');
        }
    }

    matchTiles(tile1, tile2) {
        tile1.el.classList.remove('selected');
        tile1.el.style.transform = "scale(0)";
        tile1.el.style.opacity = "0";
        tile2.el.classList.remove('selected');
        tile2.el.style.transform = "scale(0)";
        tile2.el.style.opacity = "0";

        setTimeout(() => {
            tile1.el.style.display = 'none';
            tile2.el.style.display = 'none';
        }, 200);

        tile1.active = false;
        tile2.active = false;
        this.selectedTile = null;
        
        if (!this.isAutoSolving) {
            this.score += 100 * (1 + (this.settings.difficulty === 'hard' ? 0.5 : 0));
            document.getElementById('score').innerText = this.score;
        }
        this.checkAvailableMoves();
    }

    togglePause() {
        this.isPaused = !this.isPaused;
        const modal = document.getElementById('overlay-modal');
        const board = document.getElementById('board');
        
        if(this.isPaused) {
            modal.classList.remove('hidden');
            board.classList.add('paused'); 
            document.getElementById('overlay-title').innerText = "Game Paused";
            document.getElementById('overlay-msg').innerText = "Tiles are hidden.";
            
            const actionBtn = document.getElementById('overlay-action');
            actionBtn.innerText = "Resume";
            actionBtn.onclick = () => this.togglePause();

            document.getElementById('pause-btn').innerText = "Resume";
        } else {
            modal.classList.add('hidden');
            board.classList.remove('paused');
            document.getElementById('pause-btn').innerText = "Pause";
        }
    }

    showNoMovesModal() {
        this.isPaused = true;
        const modal = document.getElementById('overlay-modal');
        modal.classList.remove('hidden');
        document.getElementById('overlay-title').innerText = "No Matches!";
        document.getElementById('overlay-msg').innerText = "There are no matching pairs available.";
        
        const actionBtn = document.getElementById('overlay-action');
        actionBtn.innerText = "Shuffle Board";
        actionBtn.onclick = () => {
            this.manualReshuffle();
            this.togglePause();
        };
    }

    hint() {
        if(this.isPaused || this.isAutoSolving) return;
        const freeTiles = this.checkAvailableMoves();
        
        let pair = null;
        for(let i=0; i<freeTiles.length; i++) {
            for(let j=i+1; j<freeTiles.length; j++) {
                if(freeTiles[i].val === freeTiles[j].val) {
                    pair = [freeTiles[i], freeTiles[j]];
                    break;
                }
            }
            if(pair) break;
        }

        if(pair) {
            this.score -= 50; 
            document.getElementById('score').innerText = this.score;
            pair[0].el.classList.add('hint-glow');
            pair[1].el.classList.add('hint-glow');
            setTimeout(() => {
                pair[0].el.classList.remove('hint-glow');
                pair[1].el.classList.remove('hint-glow');
            }, 2000);
        } else {
            this.showNoMovesModal();
        }
    }

    manualReshuffle() {
        this.performShuffle();
    }

    performShuffle() {
        const activeTiles = this.tiles.filter(t => t.active);
        const values = activeTiles.map(t => t.val);
        
        if(values.length % 2 !== 0) return; 

        values.sort(() => Math.random() - 0.5);

        activeTiles.forEach((t, i) => {
            t.val = values[i];
            t.el.textContent = values[i];
            t.el.style.transition = 'none';
            t.el.style.filter = 'sepia(1)';
            setTimeout(() => {
                t.el.style.transition = '';
                t.el.style.filter = '';
            }, 300);
        });

        if(this.selectedTile) {
            this.selectedTile.el.classList.remove('selected');
            this.selectedTile = null;
        }
        this.checkAvailableMoves();
    }

    startAutoSolve() {
        if(this.isAutoSolving) return;
        if(this.isPaused) this.togglePause();
        if(!confirm("Start Auto-Solve? This will solve the rest of the board without earning score.")) return;

        this.isAutoSolving = true;
        this.autoSolveStep();
    }

    showToast(msg) {
        const toast = document.getElementById('toast');
        toast.innerText = msg;
        toast.style.display = 'block';
        setTimeout(() => toast.style.display = 'none', 1500);
    }

    autoSolveStep() {
        if(!this.isAutoSolving) return;

        const freeTiles = this.checkAvailableMoves();
        
        let pair = null;
        for(let i=0; i<freeTiles.length; i++) {
            for(let j=i+1; j<freeTiles.length; j++) {
                if(freeTiles[i].val === freeTiles[j].val) {
                    pair = [freeTiles[i], freeTiles[j]];
                    break;
                }
            }
            if(pair) break;
        }

        if(pair) {
            pair[0].el.classList.add('selected');
            pair[1].el.classList.add('selected');

            setTimeout(() => {
                this.matchTiles(pair[0], pair[1]);
                setTimeout(() => this.autoSolveStep(), 600);
            }, 600);
        } else {
            const remaining = this.tiles.filter(t => t.active).length;
            if(remaining > 0) {
                this.showToast("No matches. Shuffling...");
                const wasPaused = this.isPaused;
                this.isPaused = true;
                this.performShuffle();
                setTimeout(() => {
                    this.isPaused = wasPaused;
                    this.autoSolveStep();
                }, 1000);
            } else {
                this.gameOver(true);
            }
        }
    }

    quit() {
        this.isAutoSolving = false;
        this.isPaused = false;
        clearInterval(this.timerInterval);
        document.getElementById('overlay-modal').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
    }

    gameOver(win) {
        clearInterval(this.timerInterval);
        this.isAutoSolving = false;
        const modal = document.getElementById('overlay-modal');
        modal.classList.remove('hidden');
        document.getElementById('overlay-title').innerText = win ? "You Win!" : "Game Over";
        document.getElementById('overlay-msg').innerText = `Final Score: ${this.score}\nTime: ${document.getElementById('timer').innerText}`;
        
        const actionBtn = document.getElementById('overlay-action');
        actionBtn.innerText = "Play Again";
        actionBtn.onclick = () => this.restart();
        
        document.getElementById('pause-btn').innerText = "Pause";
    }

    adjustZoom() {
        const container = document.getElementById('game-container');
        const board = document.getElementById('board');
        const padding = 20; // Safety margin
        
        // 1. Get container size
        const availableW = container.clientWidth - padding;
        const availableH = container.clientHeight - padding - 40; // Extra buffer for top controls
        
        // 2. Get actual board size (set by initBoard)
        const boardW = parseInt(board.style.width, 10);
        const boardH = parseInt(board.style.height, 10);

        if(!boardW || !boardH) return;

        // 3. Calculate Scale
        const scaleX = availableW / boardW;
        const scaleY = availableH / boardH;
        
        // Use the smaller scale to fit the whole board
        // Max scale limit removed to allow huge tiles on phone if space permits
        const scale = Math.min(scaleX, scaleY); 

        board.style.transform = `scale(${scale})`;
    }
}

const game = new MahjongGame();

</script>
</body>
</html>
